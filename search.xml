<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java 常见的OOM故障</title>
      <link href="2022/08/19/Java%20%E5%B8%B8%E8%A7%81%E7%9A%84OOM%E6%95%85%E9%9A%9C/"/>
      <url>2022/08/19/Java%20%E5%B8%B8%E8%A7%81%E7%9A%84OOM%E6%95%85%E9%9A%9C/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 常见的OOM故障.assets/iIW3y2qmh9bzkUzA.png" alt="iIW3y2qmh9bzkUzA.png" border="0" style="zoom:80%;"><h1 id="栈内存溢出">栈内存溢出</h1><p><code>java.lang.StackOverflowError</code>：栈空间溢出 ，<strong>递归调用卡死</strong></p><h1 id="堆内存溢出">堆内存溢出</h1><p><code>java.lang.OutOfMemoryError:Java heap space</code>：堆内存溢出，<strong>对象过大</strong>，堆内存不够用</p><h1 id="gc-回收时间过长">GC 回收时间过长</h1><p><code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code></p><p>过长的定义是，超过 98%的时间都用来做 GC，但是只回收了不到 2%的堆内存。假如不抛出 GC overhead limit exceeded，那么 GC 清理的内存很快会被再次填满，迫使 GC 再次执行，这样就形成了恶性循环，虽然 cpu 使用率一直是 100%，但是 GC 却没有任何效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JVM参数配置演示</span></span><br><span class="line"><span class="comment"> * -Xms10m -Xmx10m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        list.add(String.valueOf(++i).intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;********&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="直接内存溢出">直接内存溢出</h1><p><code>java.lang.OutOfMemoryError:Direct buffer memory</code></p><p><strong>元空间并不在虚拟机中，而是使用本地内存</strong>。16G 的物理内存，本地内存大约占 4G，元空间只占 20M。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数配置演示</span></span><br><span class="line"><span class="comment"> * -XX:MaxDirectMemorySize=5m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;配置的maxDirectMemory：&quot;</span>+(sum.misc.VM.maxDirectMemory() / (<span class="keyword">double</span>)<span class="number">1024</span>/<span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ByteBuffer bb = ByteBuffer.allocateDirect(<span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写 NIO 程序经常使用 ByteBuffer 来读取或写入数据，这是一种基于通道（Channel）与缓存区（Buffer) 的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在 java 堆和 native 堆中来回复制数据。</p><ul><li><p>ByteBuffer.allocate(capability) 第一种方式是分配 JVM 堆内存，属于 GC 管辖范围，由于需要拷贝，所以速度相对较慢</p></li><li><p>ByteBuffer.alloctedDirect(capability) 第二种方式分配 OS 本地内存，不属于 GC 管辖范围，不需要拷贝，速度较快</p></li></ul><p>但如果不断分配本地内存，堆内存很少使用，那么 jvm 就不需要执行 GC，DirectByteBuffer 对象就不会被回收，这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现 OutOfMemoryError，那程序就直接崩溃了。</p><h1 id="不能再创建新的本地线程">不能再创建新的本地线程</h1><p><code>java.lang.OutOfMemoryError:unable to create new native thread</code></p><p>高并发请求服务器时，经常出现此异常，准确的讲该异常与对应的操作系统有关。</p><p>导致原因：</p><ul><li>应用创建了太多线程，一个应用进程创建了多个线程，超过系统承载极限</li><li>你的服务器并不允许你的应用程序创建这么多线程，linux 系统默认允许单个进程可以创建的线程数是 1024，超过这个数量，就会报错</li></ul><p>解决办法：</p><ul><li>降低应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，降到最低</li><li>修改 linux 服务器配置，扩大 linux 默认限制</li></ul><h1 id="元空间溢出">元空间溢出</h1><p><code>java.lang.OutOfMemoryError:Metaspace</code></p><p>jdk1.8 之后元空间主要存放了虚拟机加载的类的信息，而常量池、静态变量存储在堆内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数配置演示</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">               i++;</span><br><span class="line">               Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">               enhancer.setSuperclass(OOMTest.class);</span><br><span class="line">               enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">               enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor()&#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o,Method method,Object[] objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          MethodProxy methodProxy)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                       <span class="keyword">return</span> methodProxy.invokeSuper(o,args);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               enhancer.create();</span><br><span class="line">           &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            System.out.println(i+<span class="string">&quot;次后发生了异常&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 垃圾收集器</title>
      <link href="2022/08/14/JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>2022/08/14/JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>GC 算法（复制/标记清除/标记整理）是内存回收的方法论，垃圾收集器就是算法的具体实现。</p><p>目前为止没有完美的垃圾收集器出现，更没有万能的垃圾收集器，只能针对具体的应用场景来选择合适的垃圾收集器。</p><h1 id="垃圾收集的方式">垃圾收集的方式</h1><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/r7F7Vj2mf9bilJIi.png" alt="r7F7Vj2mf9bilJIi.png" border="0"><ol><li><p>Serial 串行回收</p><p>为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，不适合服务器环境。</p><p>举例：顾客在餐厅吃饭，假如此时餐厅需要打扫卫生。只有一个服务员打扫卫生，同时要求顾客暂时离开。</p></li><li><p>Parallel 并行回收</p><p>多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理首台处理等弱交互场景。</p><p>举例：多个服务员一起打扫卫生，但是仍要求顾客暂时离开。</p></li><li><p>CMS 并发标记清除</p><p>用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），几乎不需要停顿用户线程，互联网公司多用它，适用对响应时间有要求、强交互的场景。</p><p>举例：多个服务员一起打扫卫生，同时顾客不需要离开，不影响顾客就餐。</p></li><li><p>G1</p><p>将堆内存分割成不同的区域，然后并发的对其进行垃圾回收。</p><p>举例：把餐厅划分为多个包厢，服务员只会打扫空的包厢，不影响顾客就餐。</p></li><li><p>ZGC</p><p>Java 11/12 才出现。</p></li></ol><h1 id="7-大垃圾收集器">7 大垃圾收集器</h1><p>红色叉号表示 java8 版本开始，对应的垃圾收集器 Deprecated，不推荐使用。</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/ATiSNAy15CK8sGVN.png" alt="ATiSNAy15CK8sGVN.png" border="0" style="zoom:80%;"><h2 id="新生代">新生代</h2><h3 id="串行-serial-收集器">串行 Serial 收集器</h3><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/t7vf86siV9dGBo70.jpg" alt="t7vf86siV9dGBo70.jpg" border="0"><p>只有一个线程进行垃圾收集工作，在进行垃圾收集的时候，必须暂停其他所有的工作线程。</p><ul><li>优点：对于限定单个 CPU 环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此 Serial 垃圾收集器依然是 Java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。</li><li>缺点：在进行垃圾收集过程中可能会产生较长的停顿（Stop-The-World 状态）。</li><li>开启方式：<strong>-XX:+UseSerialGC</strong>，开启后会使用 Serial（Young 区）+ Serial Old（Old 区）的收集器组合，表示新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用 “标记 - 整理” 算法。</li><li>垃圾收集时日志显示：DefNew    -----    Tenured</li></ul><h3 id="并行-parnew-收集器">并行 ParNew 收集器</h3><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/yaTZlPR4leANG4Xq.jpg" alt="yaTZlPR4leANG4Xq.jpg" border="0"><p>它是 Serial 收集器的多线程版本。它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p><ul><li><p>缺点：在进行垃圾收集过程中可能会产生较长的停顿（Stop-The-World 状态）。</p></li><li><p>开启方式：：<strong>-XX:+UseParNewGC</strong> ，开启后会使用 ParNew（Young 区）+ Serial Old（Old 区）的收集器组合，只影响新生代的收集，不影响老年代，新生代使用复制算法，老年代采用 “标记 - 整理” 算法。</p></li><li><p>垃圾收集时日志显示：ParNew    ------    Tenured</p></li></ul><p>-XX:ParallelGCThreads=数字 N，N 表示启动多少个 GC 线程，如果 cpu&gt;8，n=cpu*5/8；如果 cpu&lt;8，n=当前主机 CPU 核数。</p><h3 id="并行-parallel-scavenge-收集器">并行 Parallel Scavenge 收集器</h3><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/wrUcP0GO63ZSFLDi.jpg" alt="wrUcP0GO63ZSFLDi.jpg" border="0"><p>与 ParNew 一样是多线程收集器。其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。</p><ul><li><p>开启方式：<strong>-XX:+UseParallelGC</strong>，开启后会使用 Parallel Scavenge（Young 区）+ Parallel Old（Old 区）的收集器组合。</p></li><li><p>它重点关注的是：</p><ul><li><strong>可控制的吞吐量</strong>：Thoughput = 运行用户代码时间 / 总运行时间，比如程序运行一起需要 100 分钟，用户代码运行 99 分钟，垃圾收集时间 1 分钟，吞吐量就是 99%。高吞吐量意味着高效利用 CPU 时间，它适合在后台运算而不需要太多交互的任务。</li><li><strong>自适应调节策略也是 Parallel Scavenge 收集器与 ParNew 收集器的一个重要区别：</strong>  可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间（-XX:MaxGCPauseMillis）或者最大的吞吐量。</li></ul></li><li><p>垃圾收集时日志显示：PSYoungGen    ------    ParOldGen</p></li></ul><p>-XX:ParallelGCThreads=数字 N，N 表示启动多少个 GC 线程，如果 cpu&gt;8，n=cpu*5/8；如果 cpu&lt;8，n=当前主机 CPU 核数。</p><h2 id="老年代">老年代</h2><h3 id="串行-serial-old-收集器">串行 Serial Old 收集器</h3><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/2BHcjwS08eW86Hpy.jpg" alt="2BHcjwS08eW86Hpy.jpg" border="0"><p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><h3 id="并行-parallel-old-收集器">并行 Parallel Old 收集器</h3><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/pg4rAdNpr6DqU1TN.jpg" alt="pg4rAdNpr6DqU1TN.jpg" border="0"><p>是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器的组合。</p><ul><li>开启方式：<strong>-XX:+UseParallelOldGC</strong>。</li></ul><h3 id="并发标记清除-cms-收集器">并发标记清除 CMS 收集器</h3><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/xyhKzMDUeZpm6l5s.jpg" alt="xyhKzMDUeZpm6l5s.jpg" border="0"><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是 <strong>“标记 - 清除” 算法</strong>，是一种以获取最短停顿时间为目标的收集器，适合在互联网站或者 B/S 系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。</p><ul><li>开启方式：<strong>-XX:+UseConcMarkSweepGC</strong>，开启后会使用 ParNew+CMS+Serial Old 的收集器组合，Serial Old 将作为 CMS 出错的后备收集器。</li></ul><p><strong>分为以下四个流程：</strong></p><ul><li><p>初始标记（Initial Mark）：标记 GC Roots。仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿；</p></li><li><p>并发标记（Concurrent Mark）：可达性分析。进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿；</p></li><li><p>重新标记（Remark）：修正分析结果。为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿；</p></li><li><p>并发清除（Concurrent Sweep）：不需要停顿。</p><p>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上看来 CMS 收集器的内存回收和用户线程是一起并发的执行。</p></li></ul><p><strong>具有以下缺点：</strong></p><ul><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。也就是说，<strong>CMS 必须要在老年代堆内存用尽之前完成垃圾回收</strong>，如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，从而造成较大停顿时间。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h2 id="g1-垃圾收集器">G1 垃圾收集器</h2><h3 id="g1是什么">G1是什么</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>和 CMS 相比，在以下方面表现更出色：</p><ul><li>G1 是一个由整理内存过程的垃圾收集器，不会产生很多内存碎片</li><li>G1 的 Stop The World（STW）更可控，G1 在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</li></ul><h3 id="特点">特点</h3><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/lSbdqBv5UAaYoto7.png" alt="lSbdqBv5UAaYoto7.png" border="0" style="zoom:80%;"><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离，也就是 Eden，Survivor 和 Tenured 等内存区域不再是连续的了，而是变成了一个个大小一样的 region（区域化），每个 region 从 1M 到 32M 不等。一个 region 有可能属于 Eden，Survivor 或 Tenured 内存区域。</p><p>启动时可以通过参数-XX:G1HeapRegionSize 可指定 Region 大小（1~32M，且必须是 2 的幂），默认将整堆划分为 2048 个分区。</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/Map4MsZMBzQmYECn.png" alt="Map4MsZMBzQmYECn.png" border="0" style="zoom:80%;"><h3 id="底层原理">底层原理</h3><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/T3pGBKprIX4SE5pV.jpg" alt="T3pGBKprIX4SE5pV.jpg" border="0"><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p><strong>具备如下特点：</strong></p><ul><li><p>空间整合：整体来看是基于 “标记 - 整理” 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的，这意味着运行期间不会产生内存空间碎片。</p></li><li><p>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</p></li><li><p>在 G1 中，还有一种特殊区域，<strong>Humongous</strong>区域，如果一个对象占有的空间超过了分区容量 50%以上，G1 收集器就认为这是一个大对象。这些大对象默认直接会被分配在年老代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，用来专门存放大对象。如果一个 H 区装不下，那么 G1 就会寻找连续的 H 分区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。</p></li></ul><h1 id="常见的面试题">常见的面试题</h1><ol><li>怎么查看服务器默认的垃圾收集器是哪个？</li></ol><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/JVM 垃圾收集器.assets/gizE0OkylDGB7672.png" alt="gizE0OkylDGB7672.png" border="0"><table><thead><tr><th>回收方式</th><th>JVM 命令</th></tr></thead><tbody><tr><td>Serial 串行回收</td><td>-XX: +UserSerialGC、还有一个-XX: +UserSerialOldGC 目前已被淘汰</td></tr><tr><td>Paralle 并行回收</td><td>-XX: +UserParallelGC、-XX: +UseParallelOldGC</td></tr><tr><td>CMS 并发回收</td><td>-XX: +UseConcMarkSweepGC、-XX:  +UseParNewGC</td></tr><tr><td>G1 回收</td><td>-XX: +UserG1GC</td></tr></tbody></table><ol start="2"><li><p>生产上如何配置垃圾收集器？</p><ul><li><p>单 CPU 或小内存，单机内存</p><p>-XX:+UseSerialGC-XX:+UserSerialOldGC</p></li><li><p>多 CPU，需要最大吞吐量，如后台计算型应用</p><p>-XX:+UseParallelGC    -XX:+UseParallelOldGC</p></li><li><p>多 CPU，最求低停顿时间，需快速响应，如互联网应用</p><p>-XX:+ParNewGC    -XX:+UseConcMarkSweepGC</p></li></ul></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 虚拟机</title>
      <link href="2022/08/05/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>2022/08/05/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm">JVM</h1><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 虚拟机.assets/4oZ1gf9aI5SkOrvj.png" alt="4oZ1gf9aI5SkOrvj.png" border="0" style="zoom: 60%;"><p>JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p><h2 id="三种-jvm">三种 JVM</h2><ol><li>Sun 公司的 HotSpot，使用最多</li><li>BEA 公司的 JRockit</li><li>IBM 公司的 J9 VM</li></ol><h2 id="jvm-体系结构概览">JVM 体系结构概览</h2><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 虚拟机.assets/Bomm9z8RnEF0V5pt.png" alt="Bomm9z8RnEF0V5pt.png" border="0" style="zoom:80%;"><ol><li><p>Class Loader 类加载器</p><p>负责加载 class 文件，class 文件在文件开头有特定的文件标识。</p></li><li><p>Execution Engine 执行引擎</p><p>负责解释命令（解释器），提交给操作系统执行。</p></li><li><p>Native Interface 本地接口</p><p>Java 语言本身不能对操作系统底层进行访问和操作，但是可以通过 JNI 接口调用其他语言来实现对底层的访问。</p></li><li><p>PC Register 程序计数器</p><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p></li><li><p>Native Method Stack 本地方法栈</p><p>Java 在内存中专门开辟了一块区域处理标记为 native 的代码，它的具体做法是在 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载 native libraies。</p></li><li><p>Method Area 方法区</p><p>方法区的数据被所有线程共享。 <strong>用于存放已被加载的类信息（构造方法/接口定义）、常量、静态变量等数据。</strong></p></li><li><p><strong>Java Stack 栈</strong></p><p>栈也叫栈内存，主管 Java 程序的运行，<strong>对于栈来说不存在垃圾回收问题</strong>，只要线程一结束该栈就 Over，生命周期和线程一致，是线程私有的。 <strong>用于存储局部变量表、操作数栈、常量池引用等信息。</strong></p></li><li><p><strong>heap 堆</strong></p><p>所有对象都在这里分配内存，是垃圾收集的主要区域（“GC 堆”）。</p></li></ol><h1 id="栈-stack">栈 (Stack)</h1><p>栈中的数据都是以<strong>栈帧 (Stack Frame)</strong> 的形式存在的， 栈帧用于存储局部变量表、操作数栈、常量池引用等信息，图示在一个栈中有两个栈帧：</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 虚拟机.assets/Gk18eh0DJrPqNh6y.png" alt="Gk18eh0DJrPqNh6y.png" border="0"><ul><li>栈帧 2 是最先被调用的方法，先入栈；</li><li>然后方法 2 调用了方法 1，栈帧 1 处于栈顶的位置；</li><li>栈帧 2 处于栈底，执行完毕后，依次弹出栈帧 1 和栈帧 2；</li><li>线程结束，释放栈空间。</li></ul><p><strong>每执行一个方法都会产生一个栈帧，保存到栈（后进先出）的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。</strong></p><h1 id="堆-heap">堆 (Heap)</h1><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 虚拟机.assets/48dXLFEZpMZRifMb.png" alt="48dXLFEZpMZRifMb.png" border="0" style="zoom: 67%;"><h2 id="新生代">新生代</h2><p>新生代用于存放新生的对象，一般占堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代分为伊甸区（Eden Space）和幸存者 0 区和幸存者 1 区（Survivor Space）。</p><p><strong>MinorGC 的过程（复制—&gt; 清空—&gt; 互换）：</strong></p><ol><li><p>eden、servicorFrom 复制到 servicorTo，年龄+1</p><p>首先，把 eden 和 servicorFrom 区域中存活的对象复制到 servicorTo 区域（如果有对象的年龄以及达到了老年的标准，则复制到老年代），同时把这些对象的年龄+1，如果 servicorTo 不够位置了就放到老年代。</p></li><li><p>清空 eden、servicorFrom</p><p>然后，清空 eden 和 servicorFrom 中的垃圾对象；</p></li><li><p>servicorTo 和 servicorFrom 互换</p><p>最后，servicorTo 和 servicorFrom 互换，原 servicorTo 成为下一次 GC 时的 servicorFrom 区。</p></li></ol><p>如果出现<code>Java.lang.OutOfMemoryError:Java heap space</code>异常，说明 Java 虚拟机的堆内存不够。<strong>原因有二个：</strong></p><ol><li><p>Java 虚拟机的堆内存设置不够，可以通过参数 -Xms、-Xmx 来调整，堆内存的默认最大内存是机器的四分之一；</p></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。</p></li></ol><h2 id="老年代">老年代</h2><p>老年代用于保存从新生区筛选出来的 Java 对象。</p><h2 id="永久代">永久代</h2><p><strong>JDK1.8 之后，永久代取消了，由元空间取代</strong>。</p><p>永久代是一个常驻内存区域，用于存放 JDK 自身所携带的 Class，Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存，所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。</p><p>如果出现<code>Java.lang.OutOfMemoryError:PermGen space</code>，说明是 Java 虚拟机对永久代 Perm 内存设置不够，一般出现这种情况，都是程序启动需要加载大量的第三方 jar 包。例如在一个 Tomcat 下部署了太多的应用，或者大量动态反射生成的类不断被加载，最终导致 Perm 区被占满。</p><ul><li>JDK1.6 之前：有永久代，常量池 1.6 在方法区；</li><li>JDK1.7：有永久代，但已经逐步“去永久代”，常量池 1.7 在堆；</li><li>JDK1.8 之后：无永久代，常量池 1.8 在元空间。</li></ul><h1 id="垃圾收集">垃圾收集</h1><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p><h2 id="判断一个对象是否可被回收">判断一个对象是否可被回收</h2><h3 id="引用计数算法">引用计数算法</h3><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>在两个对象出现<strong>循环引用</strong>的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        Test b = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，a 与 b 引用的对象的成员实例互相持有，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象的成员还存在互相之间的引用，导致两个 Test 对象无法被回收。</p><h3 id="可达性分析算法">可达性分析算法</h3><p>GC Roots 是一个集合，保存了很多 GC Root 对象，以每一个 GC Root 对象为起始点向下搜索，可达的对象（能够被遍历到的对象）都是存活的，不可达的对象可被回收，Java 虚拟机使用该算法来判断对象是否可被回收。</p><p>可以作为 GC Roots 的根对象的有：</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>方法区中类静态变量引用的对象</li><li>方法区中的常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 native 方法）中引用的对象</li></ul><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 虚拟机.assets/zBaRd4fetJ4P652V.png" alt="zBaRd4fetJ4P652V.png" border="0" style="zoom:80%;"><h2 id="方法区的回收">方法区的回收</h2><p>JDK 1.8 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收，但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p><p>永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><h2 id="finalize">finalize()</h2><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p><h2 id="引用类型">引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 提供了四种强度不同的引用类型。</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 虚拟机.assets/XgtILp1IBJa4UuVA.png" alt="XgtILp1IBJa4UuVA.png" border="0" style="zoom:67%;"><h3 id="强引用">强引用</h3><p>被强引用关联的对象，即使内存不够也不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h3 id="软引用">软引用</h3><p>被软引用关联的对象，只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(obj); <span class="comment">//null</span></span><br><span class="line">System.out.println(sf.get()) <span class="comment">//java.lang.Object@610455d6，因为此时内存够用，所以软引用对象不会被回收</span></span><br></pre></td></tr></table></figure><p><strong>使用场景：软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存足够的时候就保留，不够就回收</strong>。假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取则会严重影响性能，如果一次性全部加载到内存中又可能造成内存溢出。此时可以使用软引用解决这个问题。</p><p>设计思路：使用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效地避免了 OOM 的问题。</p><p><code>Map&lt;String, SoftReference&lt;BitMap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;BitMap&gt;&gt;();</code></p><h3 id="弱引用">弱引用</h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来创建弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(obj); <span class="comment">//null</span></span><br><span class="line">System.out.println(wf.get()) <span class="comment">//null，因为弱引用只能存活到下一次垃圾回收发生之前</span></span><br></pre></td></tr></table></figure><p><strong>谈谈 WeakHashMap</strong>：WeakHashMap 的 key 是弱引用（弱 key），WeakReference 也常常用于对内存敏感的程序，比如高速缓存。</p><h3 id="虚引用">虚引用</h3><p>又称为幽灵引用或者幻影引用，<strong>与其他引用不同，虚引用并不会决定对象的生命周期</strong>，也无法<strong>通过虚引用得到Reference 的 get 方法总是返回 null</strong>，因此无法访问对应的引用对象，虚引用必须和<strong>引用队列 (ReferenceQueue)</strong> 联合使用。</p><p>虚引用的意义在于说明一个对象已经进入 finalization 阶段，可以被 gc 回收，用来实现比 finalization 机制更灵活的回收操作。<strong>换句话说</strong>，设置虚引用关联的唯一目的，就是这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。</p><p>使用 PhantomReference 来创建虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="引用队列">引用队列</h3><p>Java 提供了 4 种引用类型，在垃圾回收的时候，都有自己各自的特点。ReferenceQueue 是用来配合引用工作的。</p><p>创建引用的时候可以指定关联的引用队列，当 gc 释放对象内存的时候，会把引用加入到引用队列，如果程序发现某个虚引用或者其他引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于一种通知机制。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        ReferenceQueue referenceQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">        PhantomReference phantomReference = <span class="keyword">new</span> PhantomReference(object, referenceQueue);</span><br><span class="line"></span><br><span class="line">        System.out.println(object);</span><br><span class="line">        System.out.println(phantomReference.get());</span><br><span class="line">        System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">        object = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(object);</span><br><span class="line">        System.out.println(phantomReference.get());</span><br><span class="line">        System.out.println(referenceQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@74a14482</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">=====================</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">java.lang.ref.PhantomReference@<span class="number">1540e19d</span></span><br></pre></td></tr></table></figure><h1 id="gc-三大算法">GC 三大算法</h1><h2 id="复制">复制</h2><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 虚拟机.assets/lB7HefZXmefunRkJ.png" alt="lB7HefZXmefunRkJ.png" border="0" style="zoom:80%;"><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>不足：主要不足是只使用了内存的一半。</p><p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p><h2 id="标记-清除-mark-sweep">标记 - 清除 (Mark-Sweep)</h2><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 虚拟机.assets/EjeHJk5DTVBmdmJV.png" alt="EjeHJk5DTVBmdmJV.png" border="0" style="zoom:80%;"><p>在标记阶段，程序会检查每个对象是否为存活对象，如果是存活对象，则会在该对象头部打上标记。</p><p>在清除阶段，会进行对象回收并取消标记。另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p><p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p><p>不足：</p><ul><li>标记和清除过程效率都不高；</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul><h2 id="标记-整理-mark-compact">标记 - 整理 (Mark-Compact)</h2><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 虚拟机.assets/xix25a8YPxVzKbtc.png" alt="xix25a8YPxVzKbtc.png" border="0" style="zoom:80%;"><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>优点：不会产生内存碎片</p><p>不足：需要移动大量对象，处理效率也比较低。</p><h2 id="分代收集">分代收集</h2><p><strong>分代收集的核心思想是根据对象存活的不同生命周期将内存划分为不同的域</strong>。一般将堆分为新生代和老年代。现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><ul><li><p>新生代使用：复制算法</p></li><li><p>老年代使用：标记 - 清除或者标记 - 整理算法</p></li><li><p><strong>效率</strong>：复制算法 &gt; 标记清除算法 &gt; 标记整理算法</p></li><li><p><strong>整齐度</strong>：复制算法 = 标记整理算法 &gt; 标记清除算法</p></li><li><p><strong>内存利用率</strong>：标记整理算法 = 标记清除算法 &gt; 复制算法</p></li></ul><h1 id="内存分配与回收策略">内存分配与回收策略</h1><h2 id="minor-gc-和-full-gc">Minor GC 和 Full GC</h2><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h2 id="内存分配策略">内存分配策略</h2><h3 id="对象优先在-eden-分配">对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p><h3 id="大对象直接进入老年代">大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p><h3 id="长期存活的对象进入老年代">长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h3 id="动态对象年龄判定">动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄的对象内存总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h3 id="空间分配担保">空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于<strong>历次</strong>出现此种情况时的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h2 id="full-gc-的触发条件">Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><h3 id="调用-systemgc">调用 System.gc()</h3><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h3 id="老年代空间不足">老年代空间不足</h3><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h3 id="空间分配担保失败">空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p><h3 id="jdk-17-及以前的永久代空间不足">JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h3 id="concurrent-mode-failure">Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h1 id="jvm-参数">JVM 参数</h1><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java 虚拟机.assets/eOJGYfV1R43RgEsG.png" alt="eOJGYfV1R43RgEsG.png" border="0" style="zoom:80%;"><h2 id="查看运行中-java-程序的信息">查看运行中 Java 程序的信息</h2><table><thead><tr><th>Java 命令</th><th>作用</th></tr></thead><tbody><tr><td>jps -l</td><td>查看进程信息</td></tr><tr><td>jinfo -flag 配置项 进程号</td><td>查看进程的某个配置项信息</td></tr><tr><td>jinfo -flags 进程号</td><td>查看进程的所有配置项信息<br>-Non-default VM flags：JVM 根据机器硬件配置自动修改的参数；<br>-Command line：人工调整的 JVM 参数，可以覆盖 Non-default VM flags。</td></tr></tbody></table><h2 id="jvm-参数类型">JVM 参数类型</h2><ol><li><p>标配参数（了解）</p><p><code>-version</code> 、 <code>-help</code></p><p>各个 jdk 版本之间稳定，所以标配参数很少有很大的变化。</p></li><li><p>x 参数（了解）</p><p><code>-Xint</code>、 <code>-Xcomp</code>、 <code>-Xmixed</code></p><ul><li>-Xint：解释执行</li><li>-Xcomp：第一次使用就编译成本地代码</li><li>-Xmixed：混合模式，先编译后执行</li></ul></li><li><p><strong>xx 参数</strong></p><ul><li><p>Boolean 类型</p><p>公式：<code>-XX:+或者-某个属性</code> ，+表示开启，-表示关闭</p></li><li><p>KV 设值类型</p><p>公式：<code>-XX:属性=属性值</code></p></li></ul></li></ol><h2 id="常用的-jvm-参数">常用的 JVM 参数</h2><h3 id="查询默认参数">查询默认参数</h3><table><thead><tr><th>JVM 参数</th><th>作用</th></tr></thead><tbody><tr><td>-XX:+PrintFlagsInitial</td><td>查看 JVM 的初始默认值<br><strong>java -XX:+PrintFlagsInitial -version</strong></td></tr><tr><td>-XX:+PrintFlagsFinal</td><td>查看 JVM 的默认值以及修改后的，<code>:=</code>说明是修改过的，<code>=</code>说明是初始的</td></tr><tr><td>-XX:+PrintCommandLineFlags</td><td>快速查看修改过的参数</td></tr></tbody></table><h3 id="常用配置参数">常用配置参数</h3><table><thead><tr><th>JVM 参数</th><th>作用</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆内存的大小，默认为物理内存1/64，等价于 -XX:InitialHeapSize</td></tr><tr><td>-Xmx</td><td>最大堆内存的大小，默认物理内存1/4，等价于 -XX:MaxHeapSize</td></tr><tr><td>-Xss</td><td>设置单个线程栈的大小，默认512K~1024K ，等价于 -XX:ThreadStackSize<br>如果 -XX:ThreadStackSize=0，说明该参数没有被修改过，它的默认值取决于操作系统，一般为512K~1024K</td></tr><tr><td>-Xmn</td><td>设置新生代的大小</td></tr><tr><td>-XX:MetaspaceSize</td><td>设置元空间大小<br>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现，不过元空间与永久代最大的区别在于：**元空间并不在虚拟机中，而是在本地内存中。**因此，默认元空间的大小仅受本地内存限制。</td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印详细的 GC 收集日志信息<br>[名称：GC 前内存占用-&gt; GC 后内存占用(该区内存总大小)]</td></tr><tr><td>-XX:SurvivorRatio</td><td>设置新生代中 Eden 和 S0/S1 空间的比例<br>默认 -XX:SurvivorRatio=8，即 Eden:S0:S1=8:1:1</td></tr><tr><td>-XX:NewRatio</td><td>设置新生代与老年代在堆结构的占比<br>默认 -XX:NewRatio=2，即新生代占1，老年代占2，新生代占整个堆的1/3</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>设置晋升老年代对象的年龄的阈值<br>默认 -XX:MaxTenuringThreshold=15<br>如果设置为0，新生代对象不经过 Survivor 区，直接进入老年代，对于老年代比较多的应用，可以提高效率。<br>如果将此值设置为一个较大的值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象在年轻代的存活时间，使对象在年轻代就被回收。<br>注意：jdk1.8 之后垃圾的最大年龄不能超过15</td></tr><tr><td>-XX:+UseSerialGC</td><td>使用串行垃圾回收器</td></tr><tr><td>-XX:+UseParallelGC</td><td>使用并行垃圾回收器</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java死锁及定位分析</title>
      <link href="2022/08/03/Java%E6%AD%BB%E9%94%81%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/"/>
      <url>2022/08/03/Java%E6%AD%BB%E9%94%81%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是死锁">什么是死锁</h1><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种<strong>互相等待的现象</strong>，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java死锁及定位分析.assets/AKCKnOMcyLlYXX2a.png" alt="AKCKnOMcyLlYXX2f.png" border="0" style="zoom:70%;"><h1 id="产生死锁的主要原因">产生死锁的主要原因</h1><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul><h1 id="死锁示例代码">死锁示例代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法推进下去，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB = <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldThread(lockA,lockB),<span class="string">&quot;Thread-AAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldThread(lockB,lockA),<span class="string">&quot;Thread-BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有：&quot;</span> + lockA + <span class="string">&quot;\t尝试获得：&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有：&quot;</span> + lockB + <span class="string">&quot;\t尝试获得：&quot;</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决方案">解决方案</h1><ol><li>使用<code>jps -l</code>定位进程号</li><li><code>jstack 进程号</code>找到死锁查看</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池</title>
      <link href="2022/08/01/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2022/08/01/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池">线程池</h1><h2 id="callable-接口的使用">Callable 接口的使用</h2><ul><li>Callable：返回结果并且可以抛出异常的任务。</li><li>优点：<ul><li>可以获得任务执行返回值；</li><li>通过与 Future 的结合，可以实现利用 Future 来跟踪异步计算的结果。</li></ul></li></ul><h3 id="runnable-和-callable-的区别">Runnable 和 Callable 的区别</h3><ul><li>Callable 规定的方法是 call()，Runnable 规定的方法是 run()；</li><li>Callable 的任务执行后可以有返回值，而 Runnable 的任务不可以有返回值；</li><li>call() 方法需要声明异常，run() 方法不需要声明异常；</li><li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li></ul><h3 id="示例代码">示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程中，第三种实现多线程的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//FutureTask(Callable&lt;V&gt; callable)</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        <span class="comment">//new Thread(futureTask, &quot;BBB&quot;).start();//由于是同一个任务，所以线程是复用的</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//b = futureTask.get();//main线程要求获得Callable线程的计算结果，如果没有计算完成，main线程就会被阻塞，直到Callable线程计算完成</span></span><br><span class="line">        <span class="keyword">while</span> (!futureTask.isDone()) &#123;<span class="comment">//当futureTask完成后取值</span></span><br><span class="line">            b = futureTask.get();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*******Result&quot;</span> + (a + b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Callable come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么使用线程池">为什么使用线程池</h2><p>线程池的主要特点：<strong>管理线程、线程复用、控制线程的最大并发数</strong></p><ul><li>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li>降低资源消耗，通过重复利用已创建的线程，降低线程创建和销毁造成的开销；</li><li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行；</li></ul><h2 id="如何使用线程池">如何使用线程池</h2><h3 id="架构说明">架构说明</h3><p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor、Executors、ExecutorService、ThreadPoolExecutor 这几个类。</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java线程池.assets/7Zv65nR0ZQYf8uiM.png" alt="7Zv65nR0ZQYf8uiM.png" border="0" style="zoom:80%;"><h3 id="实现方式">实现方式</h3><p>实现方式有五种，<code>Executors.newScheduledThreadPool()</code> 是带时间调度的线程池。</p><p>Java8 新推出 <code>Executors.newWorkStealingPool(int)</code>，使用当前机器上可用的处理器作为它的并行级别。</p><p><strong>重点记住以下三种</strong>：它们的底层都是通过 <code>new ThreadPoolExecutor()</code> 实现的。</p><ul><li><p><code>Executors.newFixedThreadPool(int)</code></p><p>应用场景：<strong>适合长期执行的任务，性能好很多</strong></p><p>特点：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>底层实现方式：newFixedThreadPool 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的是 LinkedBlockingQueue。</p></li><li><p><code>Executors.newSingleThreadExecutor()</code></p><p>应用场景：<strong>适合只有一个任务执行的场景</strong></p><p>特点：创建一个单线程的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</p><p>底层实现方式：newSingleThreadExecutor 将 corePoolSize 和 maximumPoolSize 都设置为 1，它使用的是  LinkedBlockingQueue。</p></li><li><p><code>Executors.newCachedThreadPool()</code></p><p>应用场景：<strong>适合执行很多短期异步的小程序或负载较轻的服务器</strong></p><p>特点：创建一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>底层实现方式：newCachedThreadPool 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的是 SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过 60s，就销毁线程。</p></li></ul><h2 id="线程池的几个重要参数">线程池的几个重要参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ol><li><strong>corePoolSize</strong>：线程池中常驻核心线程数<ul><li>在创建了线程池后，当有请求任务来了之后，就会安排线程池中的线程去执行任务</li><li>当线程池的线程数达到 corePoolSize 后，就会把到达的任务暂时放到缓存队列中</li></ul></li><li><strong>maximumPoolSize</strong>：线程池能够容纳同时执行的最大线程数，必须大于等于 1</li><li><strong>keepAliveTime</strong>：非核心的空闲线程的存活时间<ul><li>当线程池中的线程数量超过 corePoolSize ，空闲线程的空闲时间达到 keepAliveTime 值时，空闲线程会被销毁，直到剩下 corePoolSize 个线程为止</li></ul></li><li><strong>unit</strong>：keepAliveTime 的单位</li><li><strong>workQueue</strong>：任务队列（阻塞队列），被提交但尚未被执行的任务</li><li><strong>threadFactory</strong>：表示生成线程池中工作线程的线程工厂，用于创建线程，一般用默认的即可</li><li><strong>handler</strong>：拒绝策略<ul><li>当阻塞队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize），拒绝新任务的策略</li></ul></li></ol><h2 id="线程池的底层工作原理">线程池的底层工作原理</h2><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java线程池.assets/XDMxnr9QHirGOnja.png" alt="XDMxnr9QHirGOnjN.png" border="0" style="zoom:80%;"><ol><li><p>在创建了线程池之后，等待提交过来的任务请求；</p></li><li><p>当调用 <code>execute()</code> 方法添加一个请求任务时，线程池会做出如下判断：</p><ol><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入阻塞队列；</li><li>如果此时队列满了并且运行的线程数小于 maximumPoolSize，那么立刻创建非核心线程运行此任务；</li><li>如果队列满了并且正在运行的线程数量大于或等于 maxmumPoolSize，那么执行相应的拒绝策略；</li></ol></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行；</p></li><li><p>当一个线程无事可做，并且超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程会被销毁。</p></li></ol><h2 id="线程池的拒绝策略">线程池的拒绝策略</h2><ol><li><p>什么是线程池的拒绝策略</p><p>等待队列已经排满了，再也塞不下新任务了，同时线程池中的 max 线程也达到了，无法继续为新任务服务，这时我们就需要拒绝策略机制合理的处理新任务。</p></li><li><p>JDK 内置的拒绝策略</p><ul><li><p>AbortPolicy（默认）</p><p>直接抛出 RejectedExecutionException 异常，阻止系统正常运行。</p></li><li><p>CallerRunsPolicy</p><p>该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到<strong>调用者线程</strong>，调用者线程可能再次提交该任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</p></li><li><p>DiscardOldestPolicy</p><p>抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</p></li><li><p>DiscardPolicy</p><p>直接丢弃任务，不予任何处理也不抛异常。如果允许任务丢失，这是最好的一种方案。</p></li></ul></li><li><p>均实现了 RejectedExecutionHandler 接口。</p></li></ol><h1 id="如何合理配置线程池的参数">如何合理配置线程池的参数</h1><h2 id="禁用-executors-创建线程池">禁用 Executors 创建线程池</h2><p><strong>一个都不用，我们生产上只能使用自定义的！！！！为什么？</strong></p><p>线程池不允许使用 Executors 创建，试试通过 ThreadPoolExecutor 的方式，规避资源耗尽的风险。</p><ul><li>FixedThreadPool 和 SingleThreadPool 允许请求队列的长度为 Integer.MAX_VALUE，可能会堆积大量请求，从而导致 OOM 异常；</li><li>CachedThreadPool 和 ScheduledThreadPool 允许的最大线程数量为 Integer.MAX_VALUE，可能会创建大量线程，从而导致 OOM 异常。</li></ul><h2 id="自定义线程池">自定义线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第四种获得java多线程的方式--线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1L</span>,</span><br><span class="line">                                            TimeUnit.SECONDS,</span><br><span class="line">                                            <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                                            Executors.defaultThreadFactory(), </span><br><span class="line">                                            <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">        <span class="comment">//new ThreadPoolExecutor.AbortPolicy();</span></span><br><span class="line">        <span class="comment">//new ThreadPoolExecutor.CallerRunsPolicy();</span></span><br><span class="line">        <span class="comment">//new ThreadPoolExecutor.DiscardOldestPolicy();</span></span><br><span class="line">        <span class="comment">//new ThreadPoolExecutor.DiscardPolicy();</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何合理配置线程池">如何合理配置线程池</h2><p>即最大线程数应该配置多少，线程池的第二个参数。</p><ol><li><p><strong>CPU 密集型</strong></p><p>CPU 密集型的意思是该任务需要大量的运算，而没有阻塞，所以我们应该配置尽可能少的最大并发线程数量，这样我的任务被 CPU 执行的时间相对来说会更多（如果并发线程越多，那么线程争用 CPU 的可能性越大）。</p><p><strong>一般公式：CPU 核数+1</strong></p></li><li><p><strong>IO 密集型</strong></p><p>IO 密集型的意思是该任务需要大量的 IO，即大量的阻塞，为了不浪费 CPU 的运算能力，那么我们应该配置尽可能多的最大并发线程数量，这样即使有些线程被 IO 阻塞，但是还可以有一些线程在运行。这种加速主要就是利用了那些 IO 阻塞所浪费的时间。</p><p>参考公式：<strong>CPU 核数*2</strong> 或者 <strong>CPU 核数/（1-阻塞系数） 阻塞系数在 0.8~0.9 之间</strong></p><p>八核 CPU：8/（1- 0.9）= 80</p></li><li><p>查看当前操作系统的 CPU 核数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runtime runtime = Runtime.getRuntime();</span><br><span class="line">    System.out.println(runtime.availableProcessors());<span class="comment">//CPU核数</span></span><br><span class="line">    System.out.println(runtime.totalMemory() / (<span class="keyword">double</span>) <span class="number">1024</span> / (<span class="keyword">double</span>) <span class="number">1024</span>);<span class="comment">//初始堆内存的大小 -Xms</span></span><br><span class="line">    System.out.println(runtime.maxMemory() / (<span class="keyword">double</span>) <span class="number">1024</span> / (<span class="keyword">double</span>) <span class="number">1024</span>);<span class="comment">//最大堆内存的大小-Xmx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java阻塞队列</title>
      <link href="2022/07/25/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>2022/07/25/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列和阻塞队列">队列和阻塞队列</h1><p>一个阻塞队列在数据结构中所起的作用大致如下图：</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/Java阻塞队列.assets/aC2MBbcmgHAZ8KwW.png" alt="aC2MBbcmgHAZ8KwW.png" border="0" style="zoom:75%;"><p>Thread1 往阻塞队列中添加元素，而 Thread2 从阻塞队列中移除元素。</p><ul><li><p>当阻塞队列是空时，Thread2 从队列中<strong>获取</strong>元素的操作会被阻塞；</p></li><li><p>当阻塞队列是满时，Thread1 从队列中<strong>添加</strong>元素的操作会被阻塞。</p></li></ul><h2 id="阻塞队列的优点">阻塞队列的优点</h2><p>在多线程环境下，阻塞就是指在某些情况下会挂起线程，一旦满足条件，被挂起的线程又会被自动唤醒，在 concurrent 包发布以前，<strong>我们必须自己控制这些细节，尤其还要兼顾效率和线程安全</strong>，而这给我们程序带来了不小的复杂度。</p><p>使用 BlockingQueue 的好处就是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都一手包办了。</p><h2 id="blockingqueue-的核心方法">BlockingQueue 的核心方法</h2><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法类型</th><th style="text-align:left">status</th></tr></thead><tbody><tr><td style="text-align:left">抛出异常</td><td style="text-align:left">当阻塞队列满时，再往队列中add会抛<code>IllegalStateException: Queue full</code><br>当阻塞队列空时，再往队列里remove会抛<code>NoSuchElementException</code></td></tr><tr><td style="text-align:left">特殊值</td><td style="text-align:left">插入方法，成功true，失败false<br>移除方法，成功返回出队列的元素，队列里没有就返回null</td></tr><tr><td style="text-align:left">一直阻塞</td><td style="text-align:left">当阻塞队列满时，生产者线程继续往队列put元素，队列会一直阻塞生产者线程，直到put数据或响应中断退出<br>当阻塞队列空时，消费者线程继续从队列take元素，队列会一直阻塞消费者线程，直到队列可用。</td></tr><tr><td style="text-align:left">超时退出</td><td style="text-align:left">当阻塞队列满时，队列会阻塞生产者线程一定的时间，超过此时间后生产者线程会退出</td></tr></tbody></table><h1 id="种类分析和应用场景">种类分析和应用场景</h1><h2 id="种类分析">种类分析</h2><ul><li><strong>ArrayBlockingQueue</strong>：基于数组结构组成的有界阻塞队列；</li><li><strong>LinkedBlockingQueue</strong>：基于链表结构组成的有界（但大小默认值为<code>Integer.MAX_VALUE</code>）阻塞队列；</li><li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列；</li><li>DelayQueue：基于优先级队列实现的延迟无界阻塞队列；</li><li><strong>SychronousQueue</strong>：不存储元素的阻塞队列，也即单个元素的队列；</li><li>LinkedTransferQueue：基于链表结构组成的无界阻塞队列；</li><li>LinkedBlocking<strong>Deque</strong>：基于双向链表结构组成的阻塞队列。</li></ul><h2 id="sychronousqueue"><strong>SychronousQueue</strong></h2><p>SynchronousQueue 没有容量，与其他 BlockingQueue 不同，SychronousQueue 是一个不存储元素的 BlockingQueue，每一个 put 操作必须要等待一个 take 操作，否则不能继续添加元素，反之亦然。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 1&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 2&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 3&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\ttake &quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\ttake &quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\ttake &quot;</span> + blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景">应用场景</h2><h3 id="生产者消费者模式">生产者/消费者模式</h3><ul><li><p>传统版 2.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个初始值为零的变量，两个线程对其交替操作，一个加1一个减1，来5轮</span></span><br><span class="line"><span class="comment"> * 1. 线程  操作  资源类</span></span><br><span class="line"><span class="comment"> * 2. 判断  干活  通知</span></span><br><span class="line"><span class="comment"> * 3. 防止虚假唤起机制：多线程的判断使用while而不是if，不信你用多个生产者和多个消费者试试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumer_TraditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareData.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;ProductorA &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareData.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;ConsumerA  &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;<span class="comment">//资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//等待不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + number);</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//等待不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + number);</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ProductorA <span class="number">1</span><span class="number">1</span></span><br><span class="line">ConsumerA  <span class="number">4</span><span class="number">0</span></span><br><span class="line">ProductorA <span class="number">4</span><span class="number">1</span></span><br><span class="line">ConsumerA  <span class="number">2</span><span class="number">0</span></span><br><span class="line">ProductorA <span class="number">3</span><span class="number">1</span></span><br><span class="line">ConsumerA  <span class="number">1</span><span class="number">0</span></span><br><span class="line">ProductorA <span class="number">2</span><span class="number">1</span></span><br><span class="line">ConsumerA  <span class="number">5</span><span class="number">0</span></span><br><span class="line">ProductorA <span class="number">5</span><span class="number">1</span></span><br><span class="line">ConsumerA  <span class="number">3</span><span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>阻塞队列版 3.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumer_BlockQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t生产线程启动&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myProd();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Prod&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t消费线程启动&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myConsumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;5s后main叫停，线程结束&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myResource.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//默认开启，进行生产+消费</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    </span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProd</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> retValue;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            retValue = blockingQueue.offer(data, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (retValue) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t插入队列&quot;</span> + data + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t插入队列&quot;</span> + data + <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t大老板叫停了，flag=false，生产结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            result = blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == result || result.equalsIgnoreCase(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t超过2s没有取到蛋糕，消费退出&quot;</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t消费队列&quot;</span> + result + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ArrayBlockingQueue</span><br><span class="line">Productor生产线程启动</span><br><span class="line">Consumer消费线程启动</span><br><span class="line">Productor插入队列<span class="number">1</span>成功</span><br><span class="line">Consumer消费队列<span class="number">1</span>成功</span><br><span class="line">Productor插入队列<span class="number">2</span>成功</span><br><span class="line">Consumer消费队列<span class="number">2</span>成功</span><br><span class="line">Productor插入队列<span class="number">3</span>成功</span><br><span class="line">Consumer消费队列<span class="number">3</span>成功</span><br><span class="line">Consumer消费队列<span class="number">4</span>成功</span><br><span class="line">Productor插入队列<span class="number">4</span>成功</span><br><span class="line">Consumer消费队列<span class="number">5</span>成功</span><br><span class="line">Productor插入队列<span class="number">5</span>成功</span><br><span class="line">5s后main叫停，线程结束</span><br><span class="line">Productor大老板叫停了，flag=<span class="keyword">false</span>，生产结束</span><br><span class="line">Consumer超过2s没有取到蛋糕，消费退出</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程池">线程池</h3><h3 id="消息中间件">消息中间件</h3><h1 id="synchronized-和-reentrantlock">synchronized 和 ReentrantLock</h1><h2 id="区别">区别</h2><ol><li><p>原始构成</p><ul><li><p>synchronized 是 Java 的关键字，属于 JVM 层面；</p><p><strong>monitorenter</strong>：底层是通过 monitor 对象来完成，其实 wait/notify 等方法也依赖于 monitor 对象，所以只有在同步块或方法中才能调用 wait/notify 等方法</p><p><strong>monitorexit</strong> 同上。</p></li><li><p>ReentrantLock 是具体类（java.util.concurrent.locks.lock），是 api 层面的锁。</p></li></ul></li><li><p>使用方法</p><ul><li>synchronized 不需要用户去手动释放锁，当 synchronized 代码执行完后，系统会自动让线程释放对锁的占用；</li><li>ReentrantLock 则需要用户去手动释放锁，若没有主动释放锁，就有可能导致出现死锁现象，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成。</li></ul></li><li><p>等待是否可中断</p><ul><li>synchronized 等待不可中断，被 synchronized 阻塞的线程会一直等待下去，除非当前线程抛出异常或者正常运行完成；</li><li>ReentrantLock 等待可中断，设置超时方法 tryLock(long timeout, TimeUnit unit)，或者将 lockInterruptibly() 放代码块中，调用 interrupt() 方法可中断。</li></ul></li><li><p>加锁是否公平</p><ul><li>synchronized 非公平锁；</li><li>ReentrantLock 两者都可以，默认是非公平锁，构造方法可以传入 boolean 值，true 为公平锁，false 为非公平锁。</li></ul></li><li><p>锁绑定多个条件 Condition（这是使用 Lock 的好处）</p><ul><li>synchronized 没有；</li><li>ReentrantLock 用来实现分组唤醒需要要唤醒的线程们，可以精确唤醒，而不是像 synchronized 要么随机唤醒一个线程，要么唤醒全部线程。</li></ul></li></ol><h2 id="精确唤醒示例代码">精确唤醒示例代码</h2><p>使用 synchronized 实现下面的需求太麻烦，而使用 ReentrantLock 很方便，可以实现精确唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized和lock区别</span></span><br><span class="line"><span class="comment"> * ===lock可绑定多个条件，对多个线程按顺序调用===</span></span><br><span class="line"><span class="comment"> * 实现A&gt;B&gt;C三个线程启动，要求如下：</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * 紧接着</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * 。。。。</span></span><br><span class="line"><span class="comment"> * 来十轮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncAndReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;<span class="comment">//A:1 B:2 C:3</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用</title>
      <link href="2022/07/23/JUC%E4%B8%8BCountDownLatch%E3%80%81CyclicBarrier%E3%80%81Semaphore%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2022/07/23/JUC%E4%B8%8BCountDownLatch%E3%80%81CyclicBarrier%E3%80%81Semaphore%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>wait() 和 notify() 对多个线程进行并发控制太复杂，所以 JUC 提供了一种更轻松的方式实现多线程的并发控制。以下列出了三种方式。</p></blockquote><h1 id="countdownlatch火箭发射倒计时">CountDownLatch(火箭发射倒计时)</h1><h2 id="概念">概念</h2><p>它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望负责启动框架服务的线程全部启动之后再执行。</p><p>CountDownLatch 主要有两个方法，当一个或多个线程调用 await() 方法时，调用线程会被阻塞。其他线程调用 countDown() 方法会将计数器减 1，当计数器的值变为 0 时，因调用 await() 方法被阻塞的线程才会被唤醒，继续执行。</p><h2 id="示例代码">示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//general();</span></span><br><span class="line">        countDownLatchTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">general</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t上完自习，离开教室&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread--&gt;&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123; <span class="comment">//通过阻塞main线程也可以让=====班长最后关门走人最后打印</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t=====班长最后关门走人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countDownLatchTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t被灭&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, CountryEnum.forEach_CountryEnum(i).getRetMessage()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t=====秦统一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CountryEnum</span> </span>&#123;</span><br><span class="line">        ONE(<span class="number">1</span>, <span class="string">&quot;齐国&quot;</span>), TWO(<span class="number">2</span>, <span class="string">&quot;楚国&quot;</span>), THREE(<span class="number">3</span>, <span class="string">&quot;燕国&quot;</span>),</span><br><span class="line">        FOUR(<span class="number">4</span>, <span class="string">&quot;赵国&quot;</span>), FIVE(<span class="number">5</span>, <span class="string">&quot;魏国&quot;</span>), SIX(<span class="number">6</span>, <span class="string">&quot;韩国&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="keyword">private</span> Integer retCode;</span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="keyword">private</span> String retMessage;</span><br><span class="line"></span><br><span class="line">        CountryEnum(Integer retCode, String retMessage) &#123;</span><br><span class="line">            <span class="keyword">this</span>.retCode = retCode;</span><br><span class="line">            <span class="keyword">this</span>.retMessage = retMessage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CountryEnum <span class="title">forEach_CountryEnum</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            CountryEnum[] myArray = CountryEnum.values();</span><br><span class="line">            <span class="keyword">for</span> (CountryEnum countryEnum : myArray) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index == countryEnum.retCode) &#123;</span><br><span class="line">                    <span class="keyword">return</span> countryEnum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">齐国被灭</span><br><span class="line">楚国被灭</span><br><span class="line">赵国被灭</span><br><span class="line">韩国被灭</span><br><span class="line">魏国被灭</span><br><span class="line">燕国被灭</span><br><span class="line">main=====秦统一</span><br></pre></td></tr></table></figure><h1 id="cyclicbarrier集齐七颗龙珠召唤神龙">CyclicBarrier(集齐七颗龙珠召唤神龙)</h1><h2 id="概念">概念</h2><p>CyclicBarrier 的字面意思是可循环 (Cyclic) 使用的屏障 (Barrier)，它要做的事情是让一组线程到达一个屏障（也可叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会被打开，所有被屏障拦截的线程才会继续执行，线程进入屏障通过 CycliBarrier 的 await() 方法。</p><h2 id="示例代码">示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        cyclicBarrierTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cyclicBarrierTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====召唤神龙=====&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t收集到第&quot;</span> + tempInt + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>收集到第<span class="number">1</span>颗龙珠</span><br><span class="line"><span class="number">5</span>收集到第<span class="number">5</span>颗龙珠</span><br><span class="line"><span class="number">2</span>收集到第<span class="number">2</span>颗龙珠</span><br><span class="line"><span class="number">6</span>收集到第<span class="number">6</span>颗龙珠</span><br><span class="line"><span class="number">4</span>收集到第<span class="number">4</span>颗龙珠</span><br><span class="line"><span class="number">7</span>收集到第<span class="number">7</span>颗龙珠</span><br><span class="line"><span class="number">3</span>收集到第<span class="number">3</span>颗龙珠</span><br><span class="line">====召唤神龙=====</span><br></pre></td></tr></table></figure><h1 id="semaphore信号量">Semaphore(信号量)</h1><h2 id="概念">概念</h2><p>可以代替 synchronized 和 Lock，<strong>信号量主要有两个应用场景，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制，即可以控制多个线程竞争一个或多个资源。</strong></p><h2 id="示例代码">示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抢车位示例代码，一起有6台汽车，但是只有3个停车位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);<span class="comment">//模拟三个停车位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;<span class="comment">//模拟6台汽车</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t抢到车位&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//停车3s</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t停车3s后离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Car &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Car <span class="number">1</span>抢到车位</span><br><span class="line">Car <span class="number">2</span>抢到车位</span><br><span class="line">Car <span class="number">3</span>抢到车位</span><br><span class="line">Car <span class="number">1</span>停车3s后离开车位</span><br><span class="line">Car <span class="number">3</span>停车3s后离开车位</span><br><span class="line">Car <span class="number">6</span>抢到车位</span><br><span class="line">Car <span class="number">2</span>停车3s后离开车位</span><br><span class="line">Car <span class="number">4</span>抢到车位</span><br><span class="line">Car <span class="number">5</span>抢到车位</span><br><span class="line">Car <span class="number">4</span>停车3s后离开车位</span><br><span class="line">Car <span class="number">6</span>停车3s后离开车位</span><br><span class="line">Car <span class="number">5</span>停车3s后离开车位</span><br></pre></td></tr></table></figure><h1 id="小总结">小总结</h1><ul><li>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同。CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</li><li>Semaphore 其实和锁有点类似，它一般用于控制对多个资源的访问权限。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常见的几种锁</title>
      <link href="2022/07/16/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%94%81/"/>
      <url>2022/07/16/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="锁的类型">锁的类型</h1><h2 id="悲观锁-乐观锁">悲观锁、乐观锁</h2><ul><li>悲观锁和乐观锁并非是一种实际的锁，而是指一种加锁的思想，并非 Java 独有，在其他语言和数据库中都有广泛的应用</li><li>悲观锁在 Java 中一般指代常见的各种锁，比如 synchronized</li><li>乐观锁在 Java 中一般指 CAS 操作</li></ul><h2 id="公平锁-非公平锁">公平锁、非公平锁</h2><ul><li><p><strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁，类似排队打饭；</p></li><li><p><strong>非公平锁</strong>是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象；</p></li><li><p>对 Java ReentrantLock 而言，通过构造函数指定该锁是否公平，默认是非公平锁，非公平锁的优点在于吞吐量比公平锁大；对 synchronized 而言，是一种非公平锁。<strong>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个等待队列。</strong></p></li></ul><h2 id="可重入锁-递归锁">可重入锁 (递归锁)</h2><h3 id="概念">概念</h3><ul><li>同一线程外层方法获得锁之后，内层递归调用外层方法仍能获取该锁；</li><li>同一线程外层方法获得锁之后，内层调用其他同步方法仍能获取该锁；</li></ul><p>也就是说，<strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块。ReentrantLock/synchronized 就是一个典型的可重入锁，可重入锁最大的作用是避免死锁。</strong></p><h3 id="示例代码">示例代码</h3><p><strong>可重入锁代码验证：synchronized</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t -----invoked sendSMS()&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t +++++invoked sendEmail()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">2</span> -----<span class="function">invoked <span class="title">sendSMS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 2 +++++invoked <span class="title">sendEmail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 1 -----invoked <span class="title">sendSMS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 1 +++++invoked <span class="title">sendEmail</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>可重入锁代码验证：ReentrantLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mobile mobile = <span class="keyword">new</span> Mobile();</span><br><span class="line">        <span class="keyword">new</span> Thread(mobile).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mobile).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mobile</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked get()&quot;</span>);</span><br><span class="line">            set();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked set()&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> <span class="function">invoked <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-0 invoked <span class="title">set</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-1 invoked <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-1 invoked <span class="title">set</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="自旋锁">自旋锁</h2><h3 id="概念">概念</h3><p>是指尝试获取锁的线程获取失败，不会立即被阻塞，而是<strong>采用循环的方式，反复的去尝试获取该锁，直到获取成功</strong>，这样做的好处是减少线程上下文切换的消耗（线程上下文切换将导致操作系统从用户态变为内核态），缺点是循环会消耗 CPU。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自旋锁时间阈值">自旋锁时间阈值</h3><p>在 JDK1.5 自旋锁时间阈值是写死的，在 1.6 引入了<strong>适应性自旋锁</strong>， 适应性意味着自旋的次数不再固定了，而是<strong>由前一次在同一个锁对象上的自旋次数及锁的拥有者的状态来决定。</strong></p><p>适应性自旋锁基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过 (CPUs/2) 个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU 的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。</p><p><strong>自旋锁的开启</strong><br>JDK1.6 中 -XX:+UseSpinning 开启；<br>-XX:PreBlockSpin=10 为自旋次数，JDK1.7 后，去掉此参数，由 jvm 控制。</p><h3 id="手写自旋锁">手写自旋锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现自旋锁</span></span><br><span class="line"><span class="comment"> * 通过CAS操作完成自旋锁，A线程先进来调用mylock方法自己持有锁5秒钟，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.mylock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.mylock();</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked myunlock()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span> come in</span><br><span class="line">Thread <span class="number">2</span> come in <span class="comment">//Thread2 come in之后不会立即被阻塞，而是卡在while循环，自我旋转</span></span><br><span class="line">Thread <span class="number">1</span> <span class="function">invoked <span class="title">myunlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 2 invoked <span class="title">myunlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="独占锁-写锁共享锁-读锁">独占锁 (写锁)/共享锁 (读锁)</h2><h3 id="概念">概念</h3><ul><li><strong>独占锁</strong>：指该锁一次只能被一个线程所持有，ReentrantLock 和 synchronized 都是独占锁；</li><li><strong>共享锁</strong>：指该锁可被多个线程所持有，可以保证并发读是非常高效的；</li><li><strong>读写锁</strong>：为了提高性能，Java 提供了 ReentrantReadWriteLock  读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，它和 CopyOnWrite 容器不同的是 CopyOnWrite 读写不互斥，不保证数据的实时更新，而 ReentrantReadWriteLock 读写互斥，可以保证数据的实时更新。<strong>ReentrantReadWriteLock 的常见应用场景：缓存 。</strong></li></ul><h3 id="示例代码">示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个线程同时读一个资源类没有任何问题（数据一致），所以为了满足并发量，读取共享资源可以同时进行。</span></span><br><span class="line"><span class="comment"> * 但是如果有一个线程想去写共享资源，那么就不应该再有其他线程对资源进行读或写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：读读能共存、读写不能共存、写写不能共存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写操作：原子+独占</span></span><br><span class="line"><span class="comment">     * 整个过程必须是一个完整的统一体，中间不许被分割，不许被打断</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以正在写入和写入完成需要同时打印出来才行，不可以被分割</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在写入：&quot;</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t写入完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读操作不需要保证原子+独占，所以可以多个线程同时读</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以正在读取和读取完成不需要同时打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在读取：&quot;</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            Object result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t读取完成: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>正在写入：<span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span>写入完成</span><br><span class="line">Thread <span class="number">2</span>正在写入：<span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span>写入完成</span><br><span class="line">Thread <span class="number">4</span>正在写入：<span class="number">4</span></span><br><span class="line">Thread <span class="number">4</span>写入完成</span><br><span class="line">Thread <span class="number">5</span>正在写入：<span class="number">5</span></span><br><span class="line">Thread <span class="number">5</span>写入完成</span><br><span class="line">Thread <span class="number">3</span>正在写入：<span class="number">3</span></span><br><span class="line">Thread <span class="number">3</span>写入完成</span><br><span class="line">Thread <span class="number">1</span>正在读取：<span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span>正在读取：<span class="number">2</span></span><br><span class="line">Thread <span class="number">3</span>正在读取：<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>正在读取：<span class="number">4</span></span><br><span class="line">Thread <span class="number">5</span>正在读取：<span class="number">5</span></span><br><span class="line">Thread <span class="number">2</span>读取完成: <span class="number">2</span></span><br><span class="line">Thread <span class="number">5</span>读取完成: <span class="number">5</span></span><br><span class="line">Thread <span class="number">3</span>读取完成: <span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>读取完成: <span class="number">4</span></span><br><span class="line">Thread <span class="number">1</span>读取完成: <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="偏向锁轻量级锁重量级锁">偏向锁/轻量级锁/重量级锁</h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而<strong>让锁拥有了四个状态</strong>：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p><br><p><strong>重量级锁：</strong> synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁） 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到内核态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p><br><p><strong>轻量级锁：</strong> “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，<strong>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</strong></p><br><p><strong>偏向锁：</strong> Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，<strong>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</strong></p><h2 id="分段锁">分段锁</h2><p>分段锁也并非一种实际的锁，而是一种思想，ConcurrentHashMap 是学习分段锁的最好实践。</p><h1 id="锁的优化">锁的优化</h1><h2 id="减少锁持有的时间">减少锁持有的时间</h2><p>只用在有线程安全要求的程序上加锁。</p><h2 id="减少锁粒度">减少锁粒度</h2><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最典型的减小锁粒度的案例就是 ConcurrentHashMap。</p><h2 id="锁分离">锁分离</h2><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如 LinkedBlockingQueue 从头部取出，从尾部放数据。</p><h2 id="锁粗化">锁粗化</h2><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p><h2 id="锁消除">锁消除</h2><p>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。<br>参考：<a href="https://www.jianshu.com/p/39628e1180a9">Java 锁 - 导读 </a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常见的线程不安全的集合类</title>
      <link href="2022/07/15/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>2022/07/15/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>线程不安全的集合：当多个线程同时对非线程安全的集合进行增删改的时候会破坏集合的数据完整性。例如：当多个线程访问同一个集合时，如果有超过一个线程同时在修改集合，则程序必须手动保证该集合的同步性。</p><h1 id="arraylist">ArrayList</h1><h2 id="不安全的-arraylist-实例">不安全的 ArrayList 实例</h2><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合类不安全问题</span></span><br><span class="line"><span class="comment"> * ArrayList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerNotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        notSafe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 故障现象</span></span><br><span class="line"><span class="comment">     * java.util.ConcurrentModificationException：并发修改异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread 10&quot;</span> java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure><h2 id="异常原因"><s>异常原因</s></h2><p>并发修改异常：ArrayList 类的 <code>add()</code> 方法是没有添加 <code>synchronized</code> 关键字修饰的，所以多个线程可以同时进入 <code>add()</code> 方法，当一个线程正在写入，另一个线程前来抢夺，就会导致后一个线程的写入覆盖了前一个线程的写入。</p><h2 id="三种解决方法">三种解决方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();<span class="comment">//Vector线程安全</span></span><br><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());<span class="comment">//使用辅助工具类</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<span class="comment">//写时复制，读写分离</span></span><br></pre></td></tr></table></figure><ul><li><code>Vector</code> 和 <code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code> 的底层原理是一样的，都是对 add 操作添加 <code>synchronized</code> 关键字修饰，在一个线程执行 add 操作的时候，不允许其他线程进入 add 。</li><li><code>new CopyOnWriteArrayList&lt;&gt;()</code> 是通过 ReentrantLock 保证线程安全的。</li></ul><p><strong>CopyOnWriteArrayList.add 方法（加分）</strong></p><p>CopyOnWrite 容器即写时复制，读写分离，往一个容器添加元素的时候，不直接在当前容器 Object[] 添加，而是先将当前容器 Object[] 进行 copy，复制出一个新的容器 Object[] newElements，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新的容器 setArray(newElements)，这样做可以对 CopyOnWrite 容器进行并发的读，而且不需要加锁，因为原容器不会添加任何元素（数据一致），所以 CopyOnWrite 容器也是一种读写分离的思想，读和写分别在不同的容器。</p><p>下面是 CopyOnWriteArrayList.add 的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray(); <span class="comment">//原容器</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">//新容器，容量要加1</span></span><br><span class="line">        newElements[len] = e; <span class="comment">//往新容器中写</span></span><br><span class="line">        setArray(newElements); <span class="comment">//将原容器的引用指向新容器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不足</strong>：CopyOnWrite 容器读和写分别在不同的容器，读写是不互斥的，所以无法保证数据的实时更新。</p><h1 id="hashmap">HashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure><h1 id="hashset">HashSet</h1><p>HashSet 的底层是一个 HashMap，存储的值放在 HashMap 的 key 里，value 存储了一个名称为 PRESENT 的静态常量 Object 对象，也就是说 value 形同虚设。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; list = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">Set&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;(); <span class="comment">//它的底层是一个CopyOnWriteArrayList，但是它用的不是List&lt;String&gt; list的add()方法，而是addIfAbsent(e)，保证元素是唯一的</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS和ABA问题</title>
      <link href="2022/07/10/CAS%E5%92%8CABA%E9%97%AE%E9%A2%98/"/>
      <url>2022/07/10/CAS%E5%92%8CABA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="cas">CAS</h1><h2 id="compareandset-比较并交换">compareAndSet 比较并交换</h2><p><code>AtomicInteger.compareAndSet(int expect, indt update)</code>，第一个参数为当前线程认为的期望值，如果此时主内存共享变量的值和期望值一致，则进行 update 赋值，如果和期望值不一致，说明共享变量被其他线程修改过，返回 fasle，取消赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS是什么？</span></span><br><span class="line"><span class="comment"> * 比较并交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       checkCAS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCAS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">&quot;\t current data is &quot;</span> + atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2014</span>) + <span class="string">&quot;\t current data is &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span> current data is <span class="number">2019</span></span><br><span class="line"><span class="keyword">false</span> current data is <span class="number">2019</span></span><br></pre></td></tr></table></figure><h2 id="cas-底层原理">CAS 底层原理</h2><h3 id="unsafe-类">Unsafe 类</h3><p><code>atomicInteger.getAndIncrement();</code>的底层实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>); <span class="comment">//unsafe对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Unsafe 是 CAS 的核心类，存在于 <code>sun.misc</code> 包下，由于 Java 方法无法直接访问底层系统，需要通过本地（native）方法来访问。<strong>Unsafe 类中的方法大多数都是 native 修饰的，也就是说 Unsafe 类中的方法大多数都可以直接调用操作系统底层资源执行相应任务</strong>；</li><li>变量 this ，表示该变量在内存中的起始地址；</li><li>变量 valueOffset，表示该变量在内存中的偏移地址，因为 Unsafe 就是根据内存地址获取数据的；</li><li>1 表示当前变量的值加 1 （相当于 i++）。</li></ul><h3 id="底层原理">底层原理</h3><p>CAS 全称 Compare-And-Swap，<strong>它是一条 CPU 并发原语</strong>，它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值；如果不是则重新获取该位置内存的值继续比较，直到更新成功。这个过程是原子的（不可分割的）。</p><p>CAS 并发原语体现在 JAVA 语言中就是 <code>sun.misc.Unsafe</code> 类中各个方法。调用 Unsafe 类中的 CAS 方法，JVM 会帮我们实现 CAS 汇编指令，这是一种完全依赖于硬件的功能，通过它可以实现原子操作。由于 CAS 是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，<strong>也就是说 CAS 是一条 CPU 的原子指令，不会造成数据不一致问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unsafe.getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>var1：AtomicInteger 对象本身（变量在内存的起始地址）；</li><li>var2：该对象的引用地址（变量在内存的偏移地址）；</li><li>var4：需要变动的数据（加 1 操作）；</li><li>var5：期望值；</li><li>如果当前主内存的值和 var5 相同，则更新主内存的值为 var5+var4，并且返回 var5；</li><li>如果不同，继续去获取，然后再比较，直到更新完成（通过循环，反复尝试）；</li><li><strong>CAS的关键实现</strong>有CPU并发原语（比较&amp;交换的过程是原子的）、自旋（无需上下文切换&amp;能够拿到主内存的最新值）、volatile修饰变量（及时通知其他线程）。</li></ul><h3 id="cas-缺点">CAS 缺点</h3><ol><li><p><strong>循环时间长，开销大（自旋）</strong></p><p>例如 getAndAddInt 方法执行，有个 do while 循环，如果 CAS 失败，一直会进行尝试，如果 CAS 长时间不成功，可能会给 CPU 带来很大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong></p><p>对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p></li><li><p><strong>ABA 问题</strong></p></li></ol><h1 id="aba-问题">ABA 问题</h1><h2 id="aba-问题如何产生">ABA 问题如何产生</h2><p>比如<strong>线程 1</strong>从内存位置 V 取出 A，<strong>线程 2</strong>同时也从内存取出 A，并且线程 2 进行一些操作将值改为 B，然后线程 2 又将 V 位置数据改回 A，这时候线程 1 进行 CAS 操作发现内存中的值依然是 A，然后线程 1 操作成功。</p><p><strong>尽管线程 1 的 CAS 操作成功，但是不代表这个过程没有问题。</strong></p><h2 id="如何解决-aba-问题">如何解决 ABA 问题</h2><p><strong>版本号机制：为共享变量设置版本号，在进行 CAS 操作的时候，比较两者的版本号是否相等，只有相等时 CAS 操作才能执行成功，每成功执行一次 CAS 操作，共享变量的版本号要加一，版本号只会增加不会减少。</strong></p><p>示例代码（带时间戳的原子引用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ABA问题解决</span></span><br><span class="line"><span class="comment"> * AtomicStampedReference</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====以下时ABA问题的产生=====&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//保证线程1完成一次ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;=====以下时ABA问题的解决=====&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第1次版本号&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第2次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第3次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第1次版本号&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t修改是否成功&quot;</span> + result + <span class="string">&quot;\t当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t当前最新实际值：&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">=====以下时ABA问题的产生=====</span><br><span class="line"><span class="keyword">true</span><span class="number">2019</span></span><br><span class="line">=====以下时ABA问题的解决=====</span><br><span class="line">Thread <span class="number">3</span>第<span class="number">1</span>次版本号<span class="number">1</span></span><br><span class="line">Thread <span class="number">4</span>第<span class="number">1</span>次版本号<span class="number">1</span></span><br><span class="line">Thread <span class="number">3</span>第<span class="number">2</span>次版本号<span class="number">2</span></span><br><span class="line">Thread <span class="number">3</span>第<span class="number">3</span>次版本号<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>修改是否成功<span class="keyword">false</span>当前最新实际版本号：<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>当前最新实际值：<span class="number">100</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对volatile的一些理解</title>
      <link href="2022/07/07/%E5%AF%B9volatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
      <url>2022/07/07/%E5%AF%B9volatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="java-内存模型">Java 内存模型</h1><p>JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，它描述的是一组规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><p>JMM 三大特性：可见性、原子性、有序性。</p><p><strong>JMM 规范：<strong>线程在 JVM 中运行，JVM 会为每个线程创建一个</strong>工作内存</strong>，工作内存是每个线程的私有数据区域，而 Java 内存模型规定所有变量都存储在<strong>主内存</strong>，主内存是共享内存区域，所有线程都可以访问，<strong>但是线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存，<strong>不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存的</strong>变量副本拷贝</strong>，线程间的通信（传值）必须通过主内存来完成，期间访问过程如下图：</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/对volatile的一些理解.assets/6YhEwtO9QihuH0aP.png" alt="6YhEwtO9QihuH0aP.png" border="0" style="zoom:60%;"><h1 id="对-volatile-的理解">对 volatile 的理解</h1><p>volatile 是 Java 虚拟机提供的轻量级的同步机制，保证可见性、不保证原子性、禁止指令重排。</p><h2 id="保证可见性">保证可见性</h2><p>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即得到这个最新的值。</p><p>验证示例（对 num 共享变量不添加 volatile 和添加 volatile）</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证volatile的可见性</span></span><br><span class="line"><span class="comment"> * 如果int num = 0，number变量没有添加volatile关键字修饰</span></span><br><span class="line"><span class="comment"> * 添加了volatile，保证可见性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        visibilityByVolatile();<span class="comment">//验证volatile的可见性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile可以保证可见性，及时通知其他线程主内存的值已经被修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visibilityByVolatile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程暂停3s</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                myData.addToSixty();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t update value:&quot;</span> + myData.num);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二个线程是main线程</span></span><br><span class="line">        <span class="comment">//main线程首次访问num时，会从主内存中取值，所以要想演示可见性这个case，线程AAA的num增加操作要在main线程访问num之后</span></span><br><span class="line">        <span class="comment">//如果num未用volatile修饰，线程AAA修改num后，main线程不感知，num仍然等于0（CPU cache中获取num的值）</span></span><br><span class="line">        <span class="comment">//如果num用volatile修饰，线程AAA修改num后，强制main线程从主内存获取num，num等于60（跳过CPU cache）</span></span><br><span class="line">        <span class="keyword">while</span> (myData.num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果myData的num一直为零，main线程一直在这里循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t mission is over, num value is &quot;</span> + myData.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//volatile int num = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToSixty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1 come in</span><br><span class="line">thread1 update value:<span class="number">60</span></span><br><span class="line"><span class="comment">//线程进入死循环</span></span><br></pre></td></tr></table></figure><p>当我们改为<code>volatile int num = 0;</code>后的输出结果为：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread1 come in</span><br><span class="line">thread1 update value:<span class="number">60</span></span><br><span class="line">main mission is over, num value is <span class="number">60</span></span><br><span class="line"><span class="comment">//程序没有死循环，结束执行</span></span><br></pre></td></tr></table></figure><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/对volatile的一些理解.assets/h0nFCnG3WXr7dpEY.jpg" alt="h0nFCnG3WXr7dpEY.jpg" border="0" style="zoom:80%;"><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从主内存中读，跳过 CPU cache 这一步。</p><h2 id="不保证原子性">不保证原子性</h2><p>原子性：当某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，这个线程下的所有操作<strong>要么同时成功，要么同时失败</strong>。</p><p>验证示例（变量添加 volatile 关键字，方法不添加 synchronized）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证volatile不保证原子性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        atomicByVolatile();<span class="comment">//验证volatile不保证原子性</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile不保证原子性</span></span><br><span class="line"><span class="comment">     * 以及使用Atomic保证原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicByVolatile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                    myData.addSelf();</span><br><span class="line">                    myData.atomicAddSelf();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;Thread &quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等待上面的线程都计算完成后，再用main线程取得最终结果值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后台至少有两个线程，一个是main线程，一个是gc线程</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally num value is &quot;</span>+myData.num);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally atomicnum value is &quot;</span>+myData.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToSixty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i++操作被编译器编译为多条原子指令，比如：getfied、iconst、iadd、putfield，这些操作volatile无法保证原子性。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSelf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">atomicAddSelf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行三次结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">main <span class="keyword">finally</span> num value is <span class="number">19580</span></span><br><span class="line">main <span class="keyword">finally</span> atomicnum value is <span class="number">20000</span></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">main <span class="keyword">finally</span> num value is <span class="number">19999</span></span><br><span class="line">main <span class="keyword">finally</span> atomicnum value is <span class="number">20000</span></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">main <span class="keyword">finally</span> num value is <span class="number">18375</span></span><br><span class="line">main <span class="keyword">finally</span> atomicnum value is <span class="number">20000</span></span><br><span class="line"><span class="comment">//num并没有达到20000</span></span><br></pre></td></tr></table></figure><h2 id="禁止指令重排">禁止指令重排</h2><p>有序性：在计算机执行程序时，为了提高性能，编译器和处理器常常会对<strong>指令进行重排</strong>。一般分以下三种：</p><img src="https://fastly.jsdelivr.net/gh/xltanglx/CDN/blog/对volatile的一些理解.assets/iSwIov6q6TymmJIS.png" alt="iSwIov6q6TymmJIS.png" border="0"><p>处理器在进行指令重排时必须要考虑指令之间的<strong>数据依赖性</strong>，只有没有数据依赖的指令才可能被重排。</p><p>单线程环境下程序最终执行的结果和代码顺序执行的结果一致，但是多线程环境下线程交替执行，由于指令重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果也无法预测。</p><p>重排代码实例，声明变量：<code>int a,b,x,y=0</code></p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>结果</td><td>x = 0      y=0</td></tr></tbody></table><p>如果编译器对这段程序代码执行重排优化后，可能出现如下情况：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x= a;</td><td>y = b;</td></tr><tr><td>结果</td><td>x = 2      y=1</td></tr></tbody></table><p>使用 volatile 可以禁止指令重排，从而避免了多线程环境下程序出现乱序执行的现象。</p><p><strong>内存屏障</strong>（Memory Barrier）又称内存栅栏，是一个 CPU 指令，它的作用有两个：</p><ol><li>保证特定操作的执行顺序；</li><li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）。</li></ol><p><strong>重排序时不能把后面的指令放到内存屏障之前</strong>。内存屏障的另外一个作用是强制刷新各种 CPU 的缓存数据，因此任何 CPU 上的线程都能读取到这些数据的最新版本（就是可见性）。</p><h1 id="volatile-的适用场景">volatile 的适用场景</h1><p>总结：<strong>volatile 适合这种场景，一个变量被多个线程共享，线程直接给这个变量赋值。</strong></p><p>值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++ 这种操作的原子性，因为本质上 i++ 是读、写两次操作。在某些场景下可以代替 synchronized。但是，volatile 不能完全取代 synchronized 的位置，只有在一些特殊的场景下，才能使用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：</p><ul><li>对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）；</li><li>该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul><h1 id="你在哪些地方用过-volatile">你在哪些地方用过 volatile</h1><h2 id="线程不安全的单例模式">线程不安全的单例模式</h2><p>普通的单例模式在多线程情况下，其构造方法可能会被执行多次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 构造方法SingletonDemo（）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造方法只会被执行一次</span></span><br><span class="line">        <span class="comment">//System.out.println(getInstance() == getInstance());</span></span><br><span class="line">        <span class="comment">//System.out.println(getInstance() == getInstance());</span></span><br><span class="line">        <span class="comment">//System.out.println(getInstance() == getInstance());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//并发多线程后，构造方法会在一些情况下执行多次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全的单例模式">线程安全的单例模式</h2><p>所以使用 DCL （Double Check Lock双端检锁机制）在加锁前和加锁后都进行一次判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SingletonDemo.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为指令重排的存在，DCL（双端检锁）机制仍然不一定线程安全。</strong></p><p><code>instance=new SingleDemo();</code>可以被分为以下三步（伪代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;<span class="comment">//3.设置instance执行刚分配的内存地址，此时instance!=null</span></span><br></pre></td></tr></table></figure><p>步骤 2 和步骤 3 不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的，<strong>如果 3 步骤提前于步骤 2，但是 instance 还没有初始化完成，所以当一个线程访问 instance 不为 null 时，由于 instance 实例未必已初始化完成，也就造成了线程安全问题。</strong></p><p>为了解决以上问题，可以将 SingletongDemo 实例上加上 volatile。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
