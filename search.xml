<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java常见的几种锁</title>
      <link href="2022/08/14/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%94%81/"/>
      <url>2022/08/14/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="锁的类型">锁的类型</h1><h2 id="悲观锁-乐观锁">悲观锁、乐观锁</h2><ul><li>悲观锁和乐观锁并非是一种实际的锁，而是指一种加锁的思想，并非 Java 独有，在其他语言和数据库中都有广泛的应用</li><li>悲观锁在 Java 中一般指代常见的各种锁，比如 synchronized</li><li>乐观锁在 Java 中一般指 CAS 操作</li></ul><h2 id="公平锁-非公平锁">公平锁、非公平锁</h2><ul><li><p><strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁，类似排队打饭；</p></li><li><p><strong>非公平锁</strong>是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象；</p></li><li><p>对 Java ReentrantLock 而言，通过构造函数指定该锁是否公平，默认是非公平锁，非公平锁的优点在于吞吐量比公平锁大；对 synchronized 而言，是一种非公平锁。<strong>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个等待队列。</strong></p></li></ul><h2 id="可重入锁-递归锁">可重入锁 (递归锁)</h2><h3 id="概念">概念</h3><ul><li>同一线程外层方法获得锁之后，内层递归调用外层方法仍能获取该锁；</li><li>同一线程外层方法获得锁之后，内层调用其他同步方法仍能获取该锁；</li></ul><p>也就是说，<strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块。ReentrantLock/synchronized 就是一个典型的可重入锁，可重入锁最大的作用是避免死锁。</strong></p><h3 id="示例代码">示例代码</h3><p><strong>可重入锁代码验证：synchronized</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t -----invoked sendSMS()&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t +++++invoked sendEmail()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">2</span> -----<span class="function">invoked <span class="title">sendSMS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 2 +++++invoked <span class="title">sendEmail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 1 -----invoked <span class="title">sendSMS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 1 +++++invoked <span class="title">sendEmail</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>可重入锁代码验证：ReentrantLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mobile mobile = <span class="keyword">new</span> Mobile();</span><br><span class="line">        <span class="keyword">new</span> Thread(mobile).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mobile).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mobile</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked get()&quot;</span>);</span><br><span class="line">            set();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked set()&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> <span class="function">invoked <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-0 invoked <span class="title">set</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-1 invoked <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-1 invoked <span class="title">set</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="自旋锁">自旋锁</h2><h3 id="概念">概念</h3><p>是指尝试获取锁的线程获取失败，不会立即被阻塞，而是<strong>采用循环的方式，反复的去尝试获取该锁，直到获取成功</strong>，这样做的好处是减少线程上下文切换的消耗（线程上下文切换将导致操作系统从用户态变为内核态），缺点是循环会消耗 CPU。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自旋锁时间阈值">自旋锁时间阈值</h3><p>在 JDK1.5 自旋锁时间阈值是写死的，在 1.6 引入了<strong>适应性自旋锁</strong>， 适应性意味着自旋的次数不再固定了，而是<strong>由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</strong></p><p>适应性自旋锁基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过 (CPUs/2) 个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU 的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。</p><p><strong>自旋锁的开启</strong><br>JDK1.6 中 -XX:+UseSpinning 开启；<br>-XX:PreBlockSpin=10 为自旋次数，JDK1.7 后，去掉此参数，由 jvm 控制。</p><h3 id="手写自旋锁">手写自旋锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现自旋锁</span></span><br><span class="line"><span class="comment"> * 通过CAS操作完成自旋锁，A线程先进来调用mylock方法自己持有锁5秒钟，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.mylock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.mylock();</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked myunlock()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span> come in</span><br><span class="line">Thread <span class="number">2</span> come in <span class="comment">//Thread2 come in之后不会立即被阻塞，而是卡在while循环，自我旋转</span></span><br><span class="line">Thread <span class="number">1</span> <span class="function">invoked <span class="title">myunlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 2 invoked <span class="title">myunlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="独占锁-写锁共享锁-读锁">独占锁 (写锁)/共享锁 (读锁)</h2><h3 id="概念">概念</h3><ul><li><strong>独占锁</strong>：指该锁一次只能被一个线程所持有，ReentrantLock 和 synchronized 都是独占锁；</li><li><strong>共享锁</strong>：指该锁可被多个线程所持有，可以保证并发读是非常高效的；</li><li><strong>读写锁</strong>：为了提高性能，Java 提供了 ReentrantReadWriteLock  读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，它和 CopyOnWrite 容器不同的是 CopyOnWrite 读写不互斥，不保证数据的实时更新，而 ReentrantReadWriteLock 读写互斥，可以保证数据的实时更新。<strong>ReentrantReadWriteLock 的常见应用场景：缓存 。</strong></li></ul><h3 id="示例代码">示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个线程同时读一个资源类没有任何问题（数据一致），所以为了满足并发量，读取共享资源可以同时进行。</span></span><br><span class="line"><span class="comment"> * 但是如果有一个线程想去写共享资源，那么就不应该再有其他线程对资源进行读或写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：读读能共存、读写不能共存、写写不能共存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写操作：原子+独占</span></span><br><span class="line"><span class="comment">     * 整个过程必须是一个完整的统一体，中间不许被分割，不许被打断</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以正在写入和写入完成需要同时打印出来才行，不可以被分割</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在写入：&quot;</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t写入完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读操作不需要保证原子+独占，所以可以多个线程同时读</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以正在读取和读取完成不需要同时打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在读取：&quot;</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            Object result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t读取完成: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>正在写入：<span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span>写入完成</span><br><span class="line">Thread <span class="number">2</span>正在写入：<span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span>写入完成</span><br><span class="line">Thread <span class="number">4</span>正在写入：<span class="number">4</span></span><br><span class="line">Thread <span class="number">4</span>写入完成</span><br><span class="line">Thread <span class="number">5</span>正在写入：<span class="number">5</span></span><br><span class="line">Thread <span class="number">5</span>写入完成</span><br><span class="line">Thread <span class="number">3</span>正在写入：<span class="number">3</span></span><br><span class="line">Thread <span class="number">3</span>写入完成</span><br><span class="line">Thread <span class="number">1</span>正在读取：<span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span>正在读取：<span class="number">2</span></span><br><span class="line">Thread <span class="number">3</span>正在读取：<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>正在读取：<span class="number">4</span></span><br><span class="line">Thread <span class="number">5</span>正在读取：<span class="number">5</span></span><br><span class="line">Thread <span class="number">2</span>读取完成: <span class="number">2</span></span><br><span class="line">Thread <span class="number">5</span>读取完成: <span class="number">5</span></span><br><span class="line">Thread <span class="number">3</span>读取完成: <span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>读取完成: <span class="number">4</span></span><br><span class="line">Thread <span class="number">1</span>读取完成: <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="偏向锁轻量级锁重量级锁">偏向锁/轻量级锁/重量级锁</h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而<strong>让锁拥有了四个状态</strong>：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p><br><p><strong>重量级锁：</strong> synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁） 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到内核态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p><br><p><strong>轻量级锁：</strong> “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，<strong>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</strong></p><br><p><strong>偏向锁：</strong> Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，<strong>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</strong></p><h2 id="分段锁">分段锁</h2><p>分段锁也并非一种实际的锁，而是一种思想，ConcurrentHashMap 是学习分段锁的最好实践。</p><h1 id="锁的优化">锁的优化</h1><h2 id="减少锁持有的时间">减少锁持有的时间</h2><p>只用在有线程安全要求的程序上加锁。</p><h2 id="减少锁粒度">减少锁粒度</h2><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最典型的减小锁粒度的案例就是 ConcurrentHashMap。</p><h2 id="锁分离">锁分离</h2><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如 LinkedBlockingQueue 从头部取出，从尾部放数据。</p><h2 id="锁粗化">锁粗化</h2><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p><h2 id="锁消除">锁消除</h2><p>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。<br>参考：<a href="https://www.jianshu.com/p/39628e1180a9">Java 锁 - 导读 </a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常见的线程不安全的集合类</title>
      <link href="2022/08/12/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>2022/08/12/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="arraylist">ArrayList</h1><h2 id="不安全的-arraylist-实例">不安全的 ArrayList 实例</h2><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合类不安全问题</span></span><br><span class="line"><span class="comment"> * ArrayList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerNotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        notSafe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 故障现象</span></span><br><span class="line"><span class="comment">     * java.util.ConcurrentModificationException：并发修改异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread 10&quot;</span> java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure><h2 id="异常原因"><s>异常原因</s></h2><p>并发修改异常：ArrayList 类的 <code>add()</code> 方法是没有添加 <code>synchronized</code> 关键字修饰的，所以多个线程可以同时进入 <code>add()</code> 方法，当一个线程正在写入，另一个线程前来抢夺，就会导致后一个线程的写入覆盖了前一个线程的写入。</p><h2 id="三种解决方法">三种解决方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();<span class="comment">//Vector线程安全</span></span><br><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());<span class="comment">//使用辅助工具类</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<span class="comment">//写时复制，读写分离</span></span><br></pre></td></tr></table></figure><ul><li><code>Vector</code> 和 <code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code> 的底层原理是一样的，都是对 add 操作添加 <code>synchronized</code> 关键字修饰，在一个线程执行 add 操作的时候，不允许其他线程进入 add 。</li><li><code>new CopyOnWriteArrayList&lt;&gt;()</code> 是通过 ReentrantLock 保证线程安全的。</li></ul><p><strong>CopyOnWriteArrayList.add 方法（加分）</strong></p><p>CopyOnWrite 容器即写时复制，读写分离，往一个容器添加元素的时候，不直接在当前容器 Object[] 添加，而是先将当前容器 Object[] 进行 copy，复制出一个新的容器 Object[] newElements，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新的容器 setArray(newElements)，这样做可以对 CopyOnWrite 容器进行并发的读，而且不需要加锁，因为原容器不会添加任何元素（数据一致），所以 CopyOnWrite 容器也是一种读写分离的思想，读和写分别在不同的容器。</p><p>下面是 CopyOnWriteArrayList.add 的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray(); <span class="comment">//原容器</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">//新容器，容量要加1</span></span><br><span class="line">        newElements[len] = e; <span class="comment">//往新容器中写</span></span><br><span class="line">        setArray(newElements); <span class="comment">//将原容器的引用指向新容器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不足</strong>：CopyOnWrite 容器读和写分别在不同的容器，读写是不互斥的，所以无法保证数据的实时更新。</p><h1 id="hashmap">HashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure><h1 id="hashset">HashSet</h1><p>HashSet 的底层是一个 HashMap，存储的值放在 HashMap 的 key 里，value 存储了一个名称为 PRESENT 的静态常量 Object 对象，也就是说 value 形同虚设。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; list = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">Set&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;(); <span class="comment">//它的底层是一个CopyOnWriteArrayList，但是它用的不是List&lt;String&gt; list的add()方法，而是addIfAbsent(e)，保证元素是唯一的</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS和ABA问题</title>
      <link href="2022/08/10/CAS%E5%92%8CABA%E9%97%AE%E9%A2%98/"/>
      <url>2022/08/10/CAS%E5%92%8CABA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="cas">CAS</h1><h2 id="compareandset-比较并交换">compareAndSet 比较并交换</h2><p><code>AtomicInteger.compareAndSet(int expect, indt update)</code>，第一个参数为当前线程认为的期望值，如果此时主内存共享变量的值和期望值一致，则进行 update 赋值，如果和期望值不一致，说明共享变量被其他线程修改过，返回 fasle，取消赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS是什么？</span></span><br><span class="line"><span class="comment"> * 比较并交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       checkCAS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCAS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">&quot;\t current data is &quot;</span> + atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2014</span>) + <span class="string">&quot;\t current data is &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span> current data is <span class="number">2019</span></span><br><span class="line"><span class="keyword">false</span> current data is <span class="number">2019</span></span><br></pre></td></tr></table></figure><h2 id="cas-底层原理">CAS 底层原理</h2><h3 id="unsafe-类">Unsafe 类</h3><p><code>atomicInteger.getAndIncrement();</code>的底层实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>); <span class="comment">//unsafe对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Unsafe 是 CAS 的核心类，存在于 <code>sun.misc</code> 包下，由于 Java 方法无法直接访问底层系统，需要通过本地（native）方法来访问。<strong>Unsafe 类中的方法大多数都是 native 修饰的，也就是说 Unsafe 类中的方法大多数都可以直接调用操作系统底层资源执行相应任务</strong>；</li><li>变量 this ，表示该变量在内存中的起始地址；</li><li>变量 valueOffset，表示该变量在内存中的偏移地址，因为 Unsafe 就是根据内存地址获取数据的；</li><li>1 表示当前变量的值加 1 （相当于 i++）。</li></ul><h3 id="底层原理">底层原理</h3><p>CAS 全称 Compare-And-Swap，<strong>它是一条 CPU 并发原语</strong>，它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值；如果不是则重新获取该位置内存的值继续比较，直到更新成功。这个过程是原子的（不可分割的）。</p><p>CAS 并发原语体现在 JAVA 语言中就是 <code>sun.misc.Unsafe</code> 类中各个方法。调用 Unsafe 类中的 CAS 方法，JVM 会帮我们实现 CAS 汇编指令，这是一种完全依赖于硬件的功能，通过它可以实现原子操作。由于 CAS 是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，<strong>也就是说 CAS 是一条 CPU 的原子指令，不会造成数据不一致问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unsafe.getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>var1：AtomicInteger 对象本身（变量在内存的起始地址）；</li><li>var2：该对象的引用地址（变量在内存的偏移地址）；</li><li>var4：需要变动的数据（加 1 操作）；</li><li>var5：期望值；</li><li>如果当前主内存的值和 var5 相同，则更新主内存的值为 var5+var4，并且返回 var5；</li><li>如果不同，继续去获取，然后再比较，直到更新完成（通过循环，反复尝试）；</li><li><strong>CAS的关键实现</strong>有CPU并发原语（比较&amp;交换的过程是原子的）、自旋（无需上下文切换&amp;能够拿到主内存的最新值）、volatile修饰变量（及时通知其他线程）。</li></ul><h3 id="cas-缺点">CAS 缺点</h3><ol><li><p><strong>循环时间长，开销大（自旋）</strong></p><p>例如 getAndAddInt 方法执行，有个 do while 循环，如果 CAS 失败，一直会进行尝试，如果 CAS 长时间不成功，可能会给 CPU 带来很大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong></p><p>对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p></li><li><p><strong>ABA 问题</strong></p></li></ol><h1 id="aba-问题">ABA 问题</h1><h2 id="aba-问题如何产生">ABA 问题如何产生</h2><p>比如<strong>线程 1</strong>从内存位置 V 取出 A，<strong>线程 2</strong>同时也从内存取出 A，并且线程 2 进行一些操作将值改为 B，然后线程 2 又将 V 位置数据改回 A，这时候线程 1 进行 CAS 操作发现内存中的值依然是 A，然后线程 1 操作成功。</p><p><strong>尽管线程 1 的 CAS 操作成功，但是不代表这个过程没有问题。</strong></p><h2 id="如何解决-aba-问题">如何解决 ABA 问题</h2><p><strong>版本号机制：为共享变量设置版本号，在进行 CAS 操作的时候，比较两者的版本号是否相等，只有相等时 CAS 操作才能执行成功，每成功执行一次 CAS 操作，共享变量的版本号要加一，版本号只会增加不会减少。</strong></p><p>示例代码（带时间戳的原子引用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ABA问题解决</span></span><br><span class="line"><span class="comment"> * AtomicStampedReference</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====以下时ABA问题的产生=====&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//保证线程1完成一次ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;=====以下时ABA问题的解决=====&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第1次版本号&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第2次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第3次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第1次版本号&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t修改是否成功&quot;</span> + result + <span class="string">&quot;\t当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t当前最新实际值：&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">=====以下时ABA问题的产生=====</span><br><span class="line"><span class="keyword">true</span><span class="number">2019</span></span><br><span class="line">=====以下时ABA问题的解决=====</span><br><span class="line">Thread <span class="number">3</span>第<span class="number">1</span>次版本号<span class="number">1</span></span><br><span class="line">Thread <span class="number">4</span>第<span class="number">1</span>次版本号<span class="number">1</span></span><br><span class="line">Thread <span class="number">3</span>第<span class="number">2</span>次版本号<span class="number">2</span></span><br><span class="line">Thread <span class="number">3</span>第<span class="number">3</span>次版本号<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>修改是否成功<span class="keyword">false</span>当前最新实际版本号：<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>当前最新实际值：<span class="number">100</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对volatile的一些理解</title>
      <link href="2022/08/07/%E5%AF%B9volatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
      <url>2022/08/07/%E5%AF%B9volatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="java-内存模型">Java 内存模型</h1><p>JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，它描述的是一组规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><p>JMM 三大特性：可见性、原子性、有序性。</p><p><strong>JMM 规范：<strong>线程在 JVM 中运行，JVM 会为每个线程创建一个</strong>工作内存</strong>，工作内存是每个线程的私有数据区域，而 Java 内存模型规定所有变量都存储在<strong>主内存</strong>，主内存是共享内存区域，所有线程都可以访问，<strong>但是线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存，<strong>不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存的</strong>变量副本拷贝</strong>，线程间的通信（传值）必须通过主内存来完成，期间访问过程如下图：</p><img src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/对volatile的一些理解.assets/g4ICK9.png" alt="g4ICK9.png" border="0" style="zoom:67%;"><h1 id="对-volatile-的理解">对 volatile 的理解</h1><p>volatile 是 Java 虚拟机提供的轻量级的同步机制，保证可见性、不保证原子性、禁止指令重排。</p><h2 id="保证可见性">保证可见性</h2><p>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即得到这个最新的值。</p><p>验证示例（对 num 共享变量不添加 volatile 和添加 volatile）</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证volatile的可见性</span></span><br><span class="line"><span class="comment"> * 如果int num = 0，number变量没有添加volatile关键字修饰</span></span><br><span class="line"><span class="comment"> * 添加了volatile，保证可见性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        visibilityByVolatile();<span class="comment">//验证volatile的可见性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile可以保证可见性，及时通知其他线程主内存的值已经被修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visibilityByVolatile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程暂停3s</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                myData.addToSixty();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t update value:&quot;</span> + myData.num);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二个线程是main线程</span></span><br><span class="line">        <span class="comment">//main线程首次访问num时，会从主内存中取值，所以要想演示可见性这个case，线程AAA的num增加操作要在main线程访问num之后</span></span><br><span class="line">        <span class="comment">//如果num未用volatile修饰，线程AAA修改num后，main线程不感知，num仍然等于0（CPU cache中获取num的值）</span></span><br><span class="line">        <span class="comment">//如果num用volatile修饰，线程AAA修改num后，强制main线程从主内存获取num，num等于60（跳过CPU cache）</span></span><br><span class="line">        <span class="keyword">while</span> (myData.num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果myData的num一直为零，main线程一直在这里循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t mission is over, num value is &quot;</span> + myData.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//volatile int num = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToSixty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1 come in</span><br><span class="line">thread1 update value:<span class="number">60</span></span><br><span class="line"><span class="comment">//线程进入死循环</span></span><br></pre></td></tr></table></figure><p>当我们改为<code>volatile int num = 0;</code>后的输出结果为：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread1 come in</span><br><span class="line">thread1 update value:<span class="number">60</span></span><br><span class="line">main mission is over, num value is <span class="number">60</span></span><br><span class="line"><span class="comment">//程序没有死循环，结束执行</span></span><br></pre></td></tr></table></figure><img src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/对volatile的一些理解.assets/rCFldZ.jpg" alt="rCFldZ.jpg" border="0"><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从主内存中读，跳过 CPU cache 这一步。</p><h2 id="不保证原子性">不保证原子性</h2><p>原子性：当某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，这个线程下的所有操作<strong>要么同时成功，要么同时失败</strong>。</p><p>验证示例（变量添加 volatile 关键字，方法不添加 synchronized）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证volatile不保证原子性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        atomicByVolatile();<span class="comment">//验证volatile不保证原子性</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile不保证原子性</span></span><br><span class="line"><span class="comment">     * 以及使用Atomic保证原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicByVolatile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                    myData.addSelf();</span><br><span class="line">                    myData.atomicAddSelf();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;Thread &quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等待上面的线程都计算完成后，再用main线程取得最终结果值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后台至少有两个线程，一个是main线程，一个是gc线程</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally num value is &quot;</span>+myData.num);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally atomicnum value is &quot;</span>+myData.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToSixty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i++操作被编译器编译为多条原子指令，比如：getfied、iconst、iadd、putfield，这些操作volatile无法保证原子性。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSelf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">atomicAddSelf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行三次结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">main <span class="keyword">finally</span> num value is <span class="number">19580</span></span><br><span class="line">main <span class="keyword">finally</span> atomicnum value is <span class="number">20000</span></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">main <span class="keyword">finally</span> num value is <span class="number">19999</span></span><br><span class="line">main <span class="keyword">finally</span> atomicnum value is <span class="number">20000</span></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">main <span class="keyword">finally</span> num value is <span class="number">18375</span></span><br><span class="line">main <span class="keyword">finally</span> atomicnum value is <span class="number">20000</span></span><br><span class="line"><span class="comment">//num并没有达到20000</span></span><br></pre></td></tr></table></figure><h2 id="禁止指令重排">禁止指令重排</h2><p>有序性：在计算机执行程序时，为了提高性能，编译器和处理器常常会对<strong>指令进行重排</strong>。一般分以下三种：</p><img src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/对volatile的一些理解.assets/caytz5.png" alt="caytz5.png" border="0"><p>处理器在进行指令重排时必须要考虑指令之间的<strong>数据依赖性</strong>，只有没有数据依赖的指令才可能被重排。</p><p>单线程环境下程序最终执行的结果和代码顺序执行的结果一致，但是多线程环境下线程交替执行，由于编译器指令重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果也无法预测。</p><p>重排代码实例，声明变量：<code>int a,b,x,y=0</code></p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>结果</td><td>x = 0      y=0</td></tr></tbody></table><p>如果编译器对这段程序代码执行重排优化后，可能出现如下情况：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x= a;</td><td>y = b;</td></tr><tr><td>结果</td><td>x = 2      y=1</td></tr></tbody></table><p>使用 volatile 可以禁止指令重排，从而避免了多线程环境下程序出现乱序执行的现象。</p><p><strong>内存屏障</strong>（Memory Barrier）又称内存栅栏，是一个 CPU 指令，它的作用有两个：</p><ol><li>保证特定操作的执行顺序；</li><li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）。</li></ol><p><strong>重排序时不能把后面的指令放到内存屏障之前</strong>。内存屏障的另外一个作用是强制刷出各种 CPU 的缓存数据，因此任何 CPU 上的线程都能读取到这些数据的最新版本（就是可见性）。</p><h1 id="volatile-的适用场景">volatile 的适用场景</h1><p>总结：<strong>volatile 适合这种场景，一个变量被多个线程共享，线程直接给这个变量赋值。</strong></p><p>值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++ 这种操作的原子性，因为本质上 i++ 是读、写两次操作。在某些场景下可以代替 synchronized。但是，volatile 不能完全取代 synchronized 的位置，只有在一些特殊的场景下，才能使用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：</p><ul><li>对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）；</li><li>该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul><h1 id="你在哪些地方用过-volatile">你在哪些地方用过 volatile</h1><h2 id="线程不安全的单例模式">线程不安全的单例模式</h2><p>普通的单例模式在多线程情况下，其构造方法可能会被执行多次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 构造方法SingletonDemo（）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造方法只会被执行一次</span></span><br><span class="line">        <span class="comment">//System.out.println(getInstance() == getInstance());</span></span><br><span class="line">        <span class="comment">//System.out.println(getInstance() == getInstance());</span></span><br><span class="line">        <span class="comment">//System.out.println(getInstance() == getInstance());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//并发多线程后，构造方法会在一些情况下执行多次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全的单例模式">线程安全的单例模式</h2><p>所以使用 DCL （Double Check Lock双端检锁机制）在加锁前和加锁后都进行一次判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SingletonDemo.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为指令重排的存在，DCL（双端检锁）机制仍然不一定线程安全。</strong></p><p><code>instance=new SingleDemo();</code>可以被分为以下三步（伪代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;<span class="comment">//3.设置instance执行刚分配的内存地址，此时instance!=null</span></span><br></pre></td></tr></table></figure><p>步骤 2 和步骤 3 不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的，<strong>如果 3 步骤提前于步骤 2，但是 instance 还没有初始化完成，所以当一个线程访问 instance 不为 null 时，由于 instance 实例未必已初始化完成，也就造成了线程安全问题。</strong></p><p>为了解决以上问题，可以将 SingletongDemo 实例上加上 volatile。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
