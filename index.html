<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>xiaolinの小屋</title><meta name="author" content="xiaolin"><meta name="copyright" content="xiaolin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="长风破浪会有时">
<meta property="og:type" content="website">
<meta property="og:title" content="xiaolinの小屋">
<meta property="og:url" content="https://xltanglx.github.io/index.html">
<meta property="og:site_name" content="xiaolinの小屋">
<meta property="og:description" content="长风破浪会有时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/home/avatar.png">
<meta property="article:author" content="xiaolin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/home/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xltanglx.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a519bf3e7abee0829e6d1082096adfde";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: xiaolin","link":"链接: ","source":"来源: xiaolinの小屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'xiaolinの小屋',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-08-14 19:58:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="xiaolinの小屋" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/home/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">xiaolinの小屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">xiaolinの小屋</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2022/08/02/Java%E6%AD%BB%E9%94%81%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/" title="Java死锁及定位分析"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java死锁及定位分析.assets/YbZphT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java死锁及定位分析"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/08/02/Java%E6%AD%BB%E9%94%81%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/" title="Java死锁及定位分析">Java死锁及定位分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-08-02T15:52:54.000Z" title="发表于 2022-08-02 23:52:54">2022-08-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">什么是死锁
死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。

产生死锁的主要原因

系统资源不足
进程运行推进的顺序不合适
资源分配不当

死锁示例代码
1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.TimeUnit;/** * 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法推进下去， */public class DeadLockDemo &#123;    public static void main(String[] args) &#123;        String lockA = &quot;lockA&quot;;        String lockB = &quot;lockB&quot;; ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/07/30/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="Java线程池"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java线程池.assets/VTnxiB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java线程池"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/30/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="Java线程池">Java线程池</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-30T12:49:44.000Z" title="发表于 2022-07-30 20:49:44">2022-07-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">线程池
Callable 接口的使用

Callable：返回结果并且可以抛出异常的任务。
优点：

可以获得任务执行返回值；
通过与 Future 的结合，可以实现利用 Future 来跟踪异步计算的结果。



Runnable 和 Callable 的区别

Callable 规定的方法是 call()，Runnable规定的方法是 run()；
Callable 的任务执行后可以有返回值，而Runnable的任务不可以有返回值；
call() 方法可以抛出异常，run() 方法不可以；
运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。

示例代码
12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.Callable;import java.uti ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/07/24/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/" title="Java阻塞队列"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java阻塞队列.assets/pq4mhR.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java阻塞队列"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/24/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/" title="Java阻塞队列">Java阻塞队列</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-24T05:58:47.000Z" title="发表于 2022-07-24 13:58:47">2022-07-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">队列和阻塞队列
一个阻塞队列在数据结构中所起的作用大致如下图：

Thread1 往阻塞队列中添加元素，而 Thread2 从阻塞队列中移除元素。


当阻塞队列是空时，Thread2 从队列中获取元素的操作会被阻塞；


当阻塞队列是满时，Thread1 从队列中添加元素的操作会被阻塞。


阻塞队列的优点
在多线程环境下，阻塞就是指在某些情况下会挂起线程，一旦满足条件，被挂起的线程又会被自动唤醒，在 concurrent 包发布以前，我们必须自己控制这些细节，尤其还要兼顾效率和线程安全，而这给我们程序带来了不小的复杂度。
使用 BlockingQueue 的好处就是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都一手包办了。
BlockingQueue 的核心方法



方法类型
抛出异常
特殊值
阻塞
超时




插入
add(e)
offer(e)
put(e)
offer(e,time,unit)


移除
remove()
poll()
take()
poll(time,unit)


检查
element()
peek ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/07/23/JUC%E4%B8%8BCountDownLatch%E3%80%81CyclicBarrier%E3%80%81Semaphore%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用.assets/WotjWG.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/23/JUC%E4%B8%8BCountDownLatch%E3%80%81CyclicBarrier%E3%80%81Semaphore%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用">JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-23T07:13:23.000Z" title="发表于 2022-07-23 15:13:23">2022-07-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">
wait() 和 notify() 对多个线程进行并发控制太复杂，所以 JUC 提供了一种更轻松的方式实现多线程的并发控制。以下列出了三种方式。

CountDownLatch(火箭发射倒计时)
概念
它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望负责启动框架服务的线程全部启动之后再执行。
CountDownLatch 主要有两个方法，当一个或多个线程调用 await() 方法时，调用线程会被阻塞。其他线程调用 countDown() 方法会将计数器减 1，当计数器的值变为 0 时，因调用 await() 方法被阻塞的线程才会被唤醒，继续执行。
示例代码
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;imp ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/07/16/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%94%81/" title="Java常见的几种锁"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java常见的几种锁.assets/GzQrDj.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java常见的几种锁"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/16/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%94%81/" title="Java常见的几种锁">Java常见的几种锁</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-16T14:40:48.000Z" title="发表于 2022-07-16 22:40:48">2022-07-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">锁的类型
悲观锁、乐观锁

悲观锁和乐观锁并非是一种实际的锁，而是指一种加锁的思想，并非 Java 独有，在其他语言和数据库中都有广泛的应用
悲观锁在 Java 中一般指代常见的各种锁，比如 synchronized
乐观锁在 Java 中一般指 CAS 操作

公平锁、非公平锁


公平锁是指多个线程按照申请锁的顺序来获取锁，类似排队打饭；


非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象；


对 Java ReentrantLock 而言，通过构造函数指定该锁是否公平，默认是非公平锁，非公平锁的优点在于吞吐量比公平锁大；对 synchronized 而言，是一种非公平锁。非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个等待队列。


可重入锁 (递归锁)
概念

同一线程外层方法获得锁之后，内层递归调用外层方法仍能获取该锁；
同一线程外层方法获得锁之后，内层调用其他同步方法仍能获取该锁；

也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。Reent ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/07/15/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/" title="Java常见的线程不安全的集合类"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java常见的线程不安全的集合类.assets/Va1jOC.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java常见的线程不安全的集合类"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/15/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/" title="Java常见的线程不安全的集合类">Java常见的线程不安全的集合类</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-15T15:11:06.000Z" title="发表于 2022-07-15 23:11:06">2022-07-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">线程不安全的集合：当多个线程同时对非线程安全的集合进行增删改的时候会破坏集合的数据完整性。例如：当多个线程访问同一个集合时，如果有超过一个线程同时在修改集合，则程序必须手动保证该集合的同步性。
ArrayList
不安全的 ArrayList 实例
示例代码：
123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.List;import java.util.UUID;/** * 集合类不安全问题 * ArrayList */public class ContainerNotSafeDemo &#123;    public static void main(String[] args) &#123;        notSafe();    &#125;    /**     * 故障现象     * java.util.ConcurrentModificationException：并发修改异常     */    public static void notS ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/07/10/CAS%E5%92%8CABA%E9%97%AE%E9%A2%98/" title="CAS和ABA问题"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/CAS和ABA问题.assets/XQlKVl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CAS和ABA问题"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/10/CAS%E5%92%8CABA%E9%97%AE%E9%A2%98/" title="CAS和ABA问题">CAS和ABA问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-10T15:38:41.000Z" title="发表于 2022-07-10 23:38:41">2022-07-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">CAS
compareAndSet 比较并交换
AtomicInteger.compareAndSet(int expect, indt update)，第一个参数为当前线程认为的期望值，如果此时主内存共享变量的值和期望值一致，则进行 update 赋值，如果和期望值不一致，说明共享变量被其他线程修改过，返回 fasle，取消赋值。
123public final boolean compareAndSet(int expect, int update) &#123;    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125;
示例代码：
1234567891011121314151617import java.util.concurrent.atomic.AtomicInteger;/** * CAS是什么？ * 比较并交换 */public class CASDemo &#123;    public static void main(String[] args) &#123;       ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/07/07/%E5%AF%B9volatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/" title="对volatile的一些理解"><img class="post_bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/对volatile的一些理解.assets/jZ94wq.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="对volatile的一些理解"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/07/%E5%AF%B9volatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/" title="对volatile的一些理解">对volatile的一些理解</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-07T11:58:32.000Z" title="发表于 2022-07-07 19:58:32">2022-07-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">Java 内存模型
JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，它描述的是一组规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。
JMM 三大特性：可见性、原子性、有序性。
JMM 规范：线程在 JVM 中运行，JVM 会为每个线程创建一个工作内存，工作内存是每个线程的私有数据区域，而 Java 内存模型规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但是线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存的变量副本拷贝，线程间的通信（传值）必须通过主内存来完成，期间访问过程如下图：

对 volatile 的理解
volatile 是 Java 虚拟机提供的轻量级的同步机制，保证可见性、不保证原子性、禁止指令重排。
保证可见性
可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即得到这个最新的值。
验证示 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/home/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xiaolin</div><div class="author-info__description">长风破浪会有时</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/xltanglx"><i class="fab fa-github"></i><span>My GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">斯人如彩虹，遇上方知有。有趣的灵魂终会相遇，在此之前请先努力成为更好的自己。</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/02/Java%E6%AD%BB%E9%94%81%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/" title="Java死锁及定位分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java死锁及定位分析.assets/YbZphT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java死锁及定位分析"/></a><div class="content"><a class="title" href="/2022/08/02/Java%E6%AD%BB%E9%94%81%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/" title="Java死锁及定位分析">Java死锁及定位分析</a><time datetime="2022-08-02T15:52:54.000Z" title="发表于 2022-08-02 23:52:54">2022-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/30/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="Java线程池"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java线程池.assets/VTnxiB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java线程池"/></a><div class="content"><a class="title" href="/2022/07/30/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="Java线程池">Java线程池</a><time datetime="2022-07-30T12:49:44.000Z" title="发表于 2022-07-30 20:49:44">2022-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/24/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/" title="Java阻塞队列"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java阻塞队列.assets/pq4mhR.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java阻塞队列"/></a><div class="content"><a class="title" href="/2022/07/24/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/" title="Java阻塞队列">Java阻塞队列</a><time datetime="2022-07-24T05:58:47.000Z" title="发表于 2022-07-24 13:58:47">2022-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/23/JUC%E4%B8%8BCountDownLatch%E3%80%81CyclicBarrier%E3%80%81Semaphore%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用.assets/WotjWG.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用"/></a><div class="content"><a class="title" href="/2022/07/23/JUC%E4%B8%8BCountDownLatch%E3%80%81CyclicBarrier%E3%80%81Semaphore%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用">JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用</a><time datetime="2022-07-23T07:13:23.000Z" title="发表于 2022-07-23 15:13:23">2022-07-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/16/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%94%81/" title="Java常见的几种锁"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java常见的几种锁.assets/GzQrDj.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java常见的几种锁"/></a><div class="content"><a class="title" href="/2022/07/16/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%94%81/" title="Java常见的几种锁">Java常见的几种锁</a><time datetime="2022-07-16T14:40:48.000Z" title="发表于 2022-07-16 22:40:48">2022-07-16</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xiaolin</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(result =>{
      if (true) {
        const sub = []
        const content = result.data.content
        sub.unshift(content)
        window.typed = new Typed('#subtitle', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: false,
          backSpeed: 50,
        })
      } else {
        document.getElementById('subtitle').innerHTML = result.data.content
      }
    })
  })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>