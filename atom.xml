<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaolinの小屋</title>
  
  
  <link href="https://xltanglx.github.io/atom.xml" rel="self"/>
  
  <link href="https://xltanglx.github.io/"/>
  <updated>2022-08-14T11:42:32.101Z</updated>
  <id>https://xltanglx.github.io/</id>
  
  <author>
    <name>xiaolin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java死锁及定位分析</title>
    <link href="https://xltanglx.github.io/2022/08/02/Java%E6%AD%BB%E9%94%81%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/"/>
    <id>https://xltanglx.github.io/2022/08/02/Java%E6%AD%BB%E9%94%81%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90/</id>
    <published>2022-08-02T15:52:54.000Z</published>
    <updated>2022-08-14T11:42:32.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是死锁">什么是死锁</h1><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种<strong>互相等待的现象</strong>，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><img src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java死锁及定位分析.assets/UJ61NG.png" alt="UJ61NG.png" border="0" style="zoom:80%;"><h1 id="产生死锁的主要原因">产生死锁的主要原因</h1><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul><h1 id="死锁示例代码">死锁示例代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法推进下去，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB = <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldThread(lockA,lockB),<span class="string">&quot;Thread-AAA&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldThread(lockB,lockA),<span class="string">&quot;Thread-BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有：&quot;</span> + lockA + <span class="string">&quot;\t尝试获得：&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t自己持有：&quot;</span> + lockB + <span class="string">&quot;\t尝试获得：&quot;</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决方案">解决方案</h1><ol><li>使用<code>jps -l</code>定位进程号</li><li><code>jstack 进程号</code>找到死锁查看</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是死锁&quot;&gt;什么是死锁&lt;/h1&gt;
&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种&lt;strong&gt;互相等待的现象&lt;/strong&gt;，若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，</summary>
      
    
    
    
    <category term="Java" scheme="https://xltanglx.github.io/categories/Java/"/>
    
    
    <category term="Java多线程" scheme="https://xltanglx.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="https://xltanglx.github.io/2022/07/30/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://xltanglx.github.io/2022/07/30/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-07-30T12:49:44.000Z</published>
    <updated>2022-08-14T11:40:12.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池">线程池</h1><h2 id="callable-接口的使用">Callable 接口的使用</h2><ul><li>Callable：返回结果并且可以抛出异常的任务。</li><li>优点：<ul><li>可以获得任务执行返回值；</li><li>通过与 Future 的结合，可以实现利用 Future 来跟踪异步计算的结果。</li></ul></li></ul><h3 id="runnable-和-callable-的区别">Runnable 和 Callable 的区别</h3><ul><li>Callable 规定的方法是 call()，Runnable规定的方法是 run()；</li><li>Callable 的任务执行后可以有返回值，而Runnable的任务不可以有返回值；</li><li>call() 方法可以抛出异常，run() 方法不可以；</li><li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li></ul><h3 id="示例代码">示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程中，第三种实现多线程的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//FutureTask(Callable&lt;V&gt; callable)</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> MyThread2());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        <span class="comment">//new Thread(futureTask, &quot;BBB&quot;).start();//由于是同一个任务，所以线程是复用的</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//b = futureTask.get();//main线程要求获得Callable线程的计算结果，如果没有计算完成，main线程就会被阻塞，直到Callable线程计算完成</span></span><br><span class="line">        <span class="keyword">while</span> (!futureTask.isDone()) &#123;<span class="comment">//当futureTask完成后取值</span></span><br><span class="line">            b = futureTask.get();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;*******Result&quot;</span> + (a + b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Callable come in&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么使用线程池">为什么使用线程池</h2><p>线程池的主要特点：<strong>管理线程、线程复用、控制线程的最大并发数</strong></p><ul><li>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li>降低资源消耗，通过重复利用已创建的线程，降低线程创建和销毁造成的开销；</li><li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行；</li></ul><h2 id="如何使用线程池">如何使用线程池</h2><h3 id="架构说明">架构说明</h3><p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor、Executors、ExecutorService、ThreadPoolExecutor 这几个类。</p><img src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java线程池.assets/zkz6NB.png" alt="zkz6NB.png" border="0" style="zoom:80%;"><h3 id="实现方式">实现方式</h3><p>实现方式有五种，<code>Executors.newScheduledThreadPool()</code> 是带时间调度的线程池。</p><p>Java8 新推出 <code>Executors.newWorkStealingPool(int)</code>，使用当前机器上可用的处理器作为它的并行级别。</p><p><strong>重点记住以下三种</strong>：它们的底层都是通过 <code>new ThreadPoolExecutor()</code> 实现的。</p><ul><li><p><code>Executors.newFixedThreadPool(int)</code></p><p>应用场景：<strong>适合长期执行的任务，性能好很多</strong></p><p>特点：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>底层实现方式：newFixedThreadPool 创建的线程池 corePoolSize 和 maximumPoolSize 值是相等的，它使用的是 LinkedBlockingQueue。</p></li><li><p><code>Executors.newSingleThreadExecutor()</code></p><p>应用场景：<strong>适合只有一个任务执行的场景</strong></p><p>特点：创建一个单线程的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。</p><p>底层实现方式：newSingleThreadExecutor 将 corePoolSize 和 maximumPoolSize 都设置为 1，它使用的是  LinkedBlockingQueue。</p></li><li><p><code>Executors.newCachedThreadPool()</code></p><p>应用场景：<strong>适合执行很多短期异步的小程序或负载较轻的服务器</strong></p><p>特点：创建一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>底层实现方式：newCachedThreadPool 将 corePoolSize 设置为 0，将 maximumPoolSize 设置为 Integer.MAX_VALUE，使用的是 SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过 60s，就销毁线程。</p></li></ul><h2 id="线程池的几个重要参数">线程池的几个重要参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ol><li><strong>corePoolSize</strong>：线程池中常驻核心线程数<ul><li>在创建了线程池后，当有请求任务来了之后，就会安排线程池中的线程去执行任务</li><li>当线程池的线程数达到 corePoolSize 后，就会把到达的任务暂时放到缓存队列中</li></ul></li><li><strong>maximumPoolSize</strong>：线程池能够容纳同时执行的最大线程数，必须大于等于 1</li><li><strong>keepAliveTime</strong>：非核心的空闲线程的存活时间<ul><li>当线程池中的线程数量超过 corePoolSize ，空闲线程的空闲时间达到 keepAliveTime 值时，空闲线程会被销毁，直到剩下 corePoolSize 个线程为止</li></ul></li><li><strong>unit</strong>：keepAliveTime 的单位</li><li><strong>workQueue</strong>：任务队列（阻塞队列），被提交但尚未被执行的任务</li><li><strong>threadFactory</strong>：表示生成线程池中工作线程的线程工厂，用于创建线程，一般用默认的即可</li><li><strong>handler</strong>：拒绝策略<ul><li>当阻塞队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize），拒绝新任务的策略</li></ul></li></ol><h2 id="线程池的底层工作原理">线程池的底层工作原理</h2><img src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java线程池.assets/2Npe51.png" alt="2Npe51.png" border="0" style="zoom:80%;"><ol><li><p>在创建了线程池之后，等待提交过来的任务请求；</p></li><li><p>当调用 <code>execute()</code> 方法添加一个请求任务时，线程池会做出如下判断：</p><ol><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入阻塞队列；</li><li>如果此时队列满了并且运行的线程数小于 maximumPoolSize，那么立刻创建非核心线程运行此任务；</li><li>如果队列满了并且正在运行的线程数量大于或等于 maxmumPoolSize，那么执行相应的拒绝策略；</li></ol></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行；</p></li><li><p>当一个线程无事可做，并且超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程会被销毁。</p></li></ol><h2 id="线程池的拒绝策略">线程池的拒绝策略</h2><ol><li><p>什么是线程池的拒绝策略</p><p>等待队列已经排满了，再也塞不下新任务了，同时线程池中的 max 线程也达到了，无法继续为新任务服务，这时我们就需要拒绝策略机制合理的处理新任务。</p></li><li><p>JDK 内置的拒绝策略</p><ul><li><p>AbortPolicy（默认）</p><p>直接抛出 RejectedExecutionException 异常，阻止系统正常运行。</p></li><li><p>CallerRunsPolicy</p><p>该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到<strong>调用者线程</strong>，调用者线程可能再次提交该任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</p></li><li><p>DiscardOldestPolicy</p><p>抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</p></li><li><p>DiscardPolicy</p><p>直接丢弃任务，不予任何处理也不抛异常。如果允许任务丢失，这是最好的一种方案。</p></li></ul></li><li><p>均实现了 RejectedExecutionHandler 接口。</p></li></ol><h1 id="如何合理配置线程池的参数">如何合理配置线程池的参数</h1><h2 id="禁用-executors-创建线程池">禁用 Executors 创建线程池</h2><p><strong>一个都不用，我们生产上只能使用自定义的！！！！为什么？</strong></p><p>线程池不允许使用 Executors 创建，试试通过 ThreadPoolExecutor 的方式，规避资源耗尽的风险。</p><ul><li>FixedThreadPool 和 SingleThreadPool 允许请求队列的长度为 Integer.MAX_VALUE，可能会堆积大量请求，从而导致 OOM 异常；</li><li>CachedThreadPool 和 ScheduledThreadPool 允许的最大线程数量为 Integer.MAX_VALUE，可能会创建大量线程，从而导致 OOM 异常。</li></ul><h2 id="自定义线程池">自定义线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第四种获得java多线程的方式--线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1L</span>,</span><br><span class="line">                                            TimeUnit.SECONDS,</span><br><span class="line">                                            <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                                            Executors.defaultThreadFactory(), </span><br><span class="line">                                            <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">        <span class="comment">//new ThreadPoolExecutor.AbortPolicy();</span></span><br><span class="line">        <span class="comment">//new ThreadPoolExecutor.CallerRunsPolicy();</span></span><br><span class="line">        <span class="comment">//new ThreadPoolExecutor.DiscardOldestPolicy();</span></span><br><span class="line">        <span class="comment">//new ThreadPoolExecutor.DiscardPolicy();</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何合理配置线程池">如何合理配置线程池</h2><p>即最大线程数应该配置多少，线程池的第二个参数。</p><ol><li><p><strong>CPU 密集型</strong></p><p>CPU 密集型的意思是该任务需要大量的运算，而没有阻塞，所以我们应该配置尽可能少的最大并发线程数量，这样我的任务被 CPU 执行的时间相对来说会更多（如果并发线程越多，那么线程争用 CPU 的可能性越大）。</p><p><strong>一般公式：CPU 核数+1</strong></p></li><li><p><strong>IO 密集型</strong></p><p>IO 密集型的意思是该任务需要大量的 IO，即大量的阻塞，为了不浪费 CPU 的运算能力，那么我们应该配置尽可能多的最大并发线程数量，这样即使有些线程被 IO 阻塞，但是还可以有一些线程在运行。这种加速主要就是利用了那些 IO 阻塞所浪费的时间。</p><p>参考公式：<strong>CPU 核数*2</strong> 或者 <strong>CPU 核数/（1-阻塞系数） 阻塞系数在 0.8~0.9 之间</strong></p><p>八核 CPU：8/（1- 0.9）= 80</p></li><li><p>查看当前操作系统的 CPU 核数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runtime runtime = Runtime.getRuntime();</span><br><span class="line">    System.out.println(runtime.availableProcessors());<span class="comment">//CPU核数</span></span><br><span class="line">    System.out.println(runtime.totalMemory() / (<span class="keyword">double</span>) <span class="number">1024</span> / (<span class="keyword">double</span>) <span class="number">1024</span>);<span class="comment">//初始堆内存的大小 -Xms</span></span><br><span class="line">    System.out.println(runtime.maxMemory() / (<span class="keyword">double</span>) <span class="number">1024</span> / (<span class="keyword">double</span>) <span class="number">1024</span>);<span class="comment">//最大堆内存的大小-Xmx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池&quot;&gt;线程池&lt;/h1&gt;
&lt;h2 id=&quot;callable-接口的使用&quot;&gt;Callable 接口的使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Callable：返回结果并且可以抛出异常的任务。&lt;/li&gt;
&lt;li&gt;优点：
&lt;ul&gt;
&lt;li&gt;可以获得任务执行返回值；&lt;/li&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://xltanglx.github.io/categories/Java/"/>
    
    
    <category term="Java多线程" scheme="https://xltanglx.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java阻塞队列</title>
    <link href="https://xltanglx.github.io/2022/07/24/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://xltanglx.github.io/2022/07/24/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2022-07-24T05:58:47.000Z</published>
    <updated>2022-08-14T11:39:41.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列和阻塞队列">队列和阻塞队列</h1><p>一个阻塞队列在数据结构中所起的作用大致如下图：</p><img src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java阻塞队列.assets/StcWiV.png" alt="StcWiV.png" border="0" style="zoom:80%;"><p>Thread1 往阻塞队列中添加元素，而 Thread2 从阻塞队列中移除元素。</p><ul><li><p>当阻塞队列是空时，Thread2 从队列中<strong>获取</strong>元素的操作会被阻塞；</p></li><li><p>当阻塞队列是满时，Thread1 从队列中<strong>添加</strong>元素的操作会被阻塞。</p></li></ul><h2 id="阻塞队列的优点">阻塞队列的优点</h2><p>在多线程环境下，阻塞就是指在某些情况下会挂起线程，一旦满足条件，被挂起的线程又会被自动唤醒，在 concurrent 包发布以前，<strong>我们必须自己控制这些细节，尤其还要兼顾效率和线程安全</strong>，而这给我们程序带来了不小的复杂度。</p><p>使用 BlockingQueue 的好处就是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都一手包办了。</p><h2 id="blockingqueue-的核心方法">BlockingQueue 的核心方法</h2><table><thead><tr><th>方法类型</th><th>抛出异常</th><th>特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td>不可用</td><td>不可用</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法类型</th><th style="text-align:left">status</th></tr></thead><tbody><tr><td style="text-align:left">抛出异常</td><td style="text-align:left">当阻塞队列满时，再往队列中add会抛<code>IllegalStateException: Queue full</code><br>当阻塞队列空时，再往队列里remove会抛<code>NoSuchElementException</code></td></tr><tr><td style="text-align:left">特殊值</td><td style="text-align:left">插入方法，成功true，失败false<br>移除方法，成功返回出队列的元素，队列里没有就返回null</td></tr><tr><td style="text-align:left">一直阻塞</td><td style="text-align:left">当阻塞队列满时，生产者线程继续往队列put元素，队列会一直阻塞生产者线程，直到put数据或响应中断退出<br>当阻塞队列空时，消费者线程继续从队列take元素，队列会一直阻塞消费者线程，直到队列可用。</td></tr><tr><td style="text-align:left">超时退出</td><td style="text-align:left">当阻塞队列满时，队列会阻塞生产者线程一定的时间，超过此时间后生产者线程会退出</td></tr></tbody></table><h1 id="种类分析和应用场景">种类分析和应用场景</h1><h2 id="种类分析">种类分析</h2><ul><li><strong>ArrayBlockingQueue</strong>：基于数组结构组成的有界阻塞队列；</li><li><strong>LinkedBlockingQueue</strong>：基于链表结构组成的有界（但大小默认值为<code>Integer.MAX_VALUE</code>）阻塞队列；</li><li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列；</li><li>DelayQueue：基于优先级队列实现的延迟无界阻塞队列；</li><li><strong>SychronousQueue</strong>：不存储元素的阻塞队列，也即单个元素的队列；</li><li>LinkedTransferQueue：基于链表结构组成的无界阻塞队列；</li><li>LinkedBlocking<strong>Deque</strong>：基于双向链表结构组成的阻塞队列。</li></ul><h2 id="sychronousqueue"><strong>SychronousQueue</strong></h2><p>SynchronousQueue 没有容量，与其他 BlockingQueue 不同，SychronousQueue 是一个不存储元素的 BlockingQueue，每一个 put 操作必须要等待一个 take 操作，否则不能继续添加元素，反之亦然。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 1&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 2&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 3&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\ttake &quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\ttake &quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\ttake &quot;</span> + blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景">应用场景</h2><h3 id="生产者消费者模式">生产者/消费者模式</h3><ul><li><p>传统版 2.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个初始值为零的变量，两个线程对其交替操作，一个加1一个减1，来5轮</span></span><br><span class="line"><span class="comment"> * 1. 线程  操作  资源类</span></span><br><span class="line"><span class="comment"> * 2. 判断  干活  通知</span></span><br><span class="line"><span class="comment"> * 3. 防止虚假唤起机制：多线程的判断使用while而不是if，不信你用多个生产者和多个消费者试试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumer_TraditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareData.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;ProductorA &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareData.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;ConsumerA  &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;<span class="comment">//资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//等待不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + number);</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//等待不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + number);</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ProductorA <span class="number">1</span><span class="number">1</span></span><br><span class="line">ConsumerA  <span class="number">4</span><span class="number">0</span></span><br><span class="line">ProductorA <span class="number">4</span><span class="number">1</span></span><br><span class="line">ConsumerA  <span class="number">2</span><span class="number">0</span></span><br><span class="line">ProductorA <span class="number">3</span><span class="number">1</span></span><br><span class="line">ConsumerA  <span class="number">1</span><span class="number">0</span></span><br><span class="line">ProductorA <span class="number">2</span><span class="number">1</span></span><br><span class="line">ConsumerA  <span class="number">5</span><span class="number">0</span></span><br><span class="line">ProductorA <span class="number">5</span><span class="number">1</span></span><br><span class="line">ConsumerA  <span class="number">3</span><span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>阻塞队列版 3.0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumer_BlockQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t生产线程启动&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myProd();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Prod&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t消费线程启动&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myConsumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;5s后main叫停，线程结束&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myResource.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//默认开启，进行生产+消费</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    </span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProd</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> retValue;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            retValue = blockingQueue.offer(data, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (retValue) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t插入队列&quot;</span> + data + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t插入队列&quot;</span> + data + <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t大老板叫停了，flag=false，生产结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            result = blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == result || result.equalsIgnoreCase(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t超过2s没有取到蛋糕，消费退出&quot;</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t消费队列&quot;</span> + result + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ArrayBlockingQueue</span><br><span class="line">Productor生产线程启动</span><br><span class="line">Consumer消费线程启动</span><br><span class="line">Productor插入队列<span class="number">1</span>成功</span><br><span class="line">Consumer消费队列<span class="number">1</span>成功</span><br><span class="line">Productor插入队列<span class="number">2</span>成功</span><br><span class="line">Consumer消费队列<span class="number">2</span>成功</span><br><span class="line">Productor插入队列<span class="number">3</span>成功</span><br><span class="line">Consumer消费队列<span class="number">3</span>成功</span><br><span class="line">Consumer消费队列<span class="number">4</span>成功</span><br><span class="line">Productor插入队列<span class="number">4</span>成功</span><br><span class="line">Consumer消费队列<span class="number">5</span>成功</span><br><span class="line">Productor插入队列<span class="number">5</span>成功</span><br><span class="line">5s后main叫停，线程结束</span><br><span class="line">Productor大老板叫停了，flag=<span class="keyword">false</span>，生产结束</span><br><span class="line">Consumer超过2s没有取到蛋糕，消费退出</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程池">线程池</h3><h3 id="消息中间件">消息中间件</h3><h1 id="synchronized-和-reentrantlock">synchronized 和 ReentrantLock</h1><h2 id="区别">区别</h2><ol><li><p>原始构成</p><ul><li><p>synchronized 是 Java 的关键字，属于 JVM 层面；</p><p><strong>monitorenter</strong>：底层是通过 monitor 对象来完成，其实 wait/notify 等方法也依赖于 monitor 对象，所以只有在同步块或方法中才能调用 wait/notify 等方法</p><p><strong>monitorexit</strong> 同上。</p></li><li><p>ReentrantLock 是具体类（java.util.concurrent.locks.lock），是 api 层面的锁。</p></li></ul></li><li><p>使用方法</p><ul><li>synchronized 不需要用户去手动释放锁，当 synchronized 代码执行完后，系统会自动让线程释放对锁的占用；</li><li>ReentrantLock 则需要用户去手动释放锁，若没有主动释放锁，就有可能导致出现死锁现象，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成。</li></ul></li><li><p>等待是否可中断</p><ul><li>synchronized 等待不可中断，被 synchronized 阻塞的线程会一直等待下去，除非当前线程抛出异常或者正常运行完成；</li><li>ReentrantLock 等待可中断，设置超时方法 tryLock(long timeout, TimeUnit unit)，或者将 lockInterruptibly() 放代码块中，调用 interrupt() 方法可中断。</li></ul></li><li><p>加锁是否公平</p><ul><li>synchronized 非公平锁；</li><li>ReentrantLock 两者都可以，默认是非公平锁，构造方法可以传入 boolean 值，true 为公平锁，false 为非公平锁。</li></ul></li><li><p>锁绑定多个条件 Condition（这是使用 Lock 的好处）</p><ul><li>synchronized 没有；</li><li>ReentrantLock 用来实现分组唤醒需要要唤醒的线程们，可以精确唤醒，而不是像 synchronized 要么随机唤醒一个线程，要么唤醒全部线程。</li></ul></li></ol><h2 id="精确唤醒示例代码">精确唤醒示例代码</h2><p>使用 synchronized 实现下面的需求太麻烦，而使用 ReentrantLock 很方便，可以实现精确唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized和lock区别</span></span><br><span class="line"><span class="comment"> * ===lock可绑定多个条件，对多个线程按顺序调用===</span></span><br><span class="line"><span class="comment"> * 实现A&gt;B&gt;C三个线程启动，要求如下：</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * 紧接着</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * 。。。。</span></span><br><span class="line"><span class="comment"> * 来十轮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncAndReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareData.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;<span class="comment">//A:1 B:2 C:3</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;队列和阻塞队列&quot;&gt;队列和阻塞队列&lt;/h1&gt;
&lt;p&gt;一个阻塞队列在数据结构中所起的作用大致如下图：&lt;/p&gt;
&lt;img src=&quot;https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/Java阻塞队列.assets/StcWi</summary>
      
    
    
    
    <category term="Java" scheme="https://xltanglx.github.io/categories/Java/"/>
    
    
    <category term="Java多线程" scheme="https://xltanglx.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC下CountDownLatch、CyclicBarrier、Semaphore的简单使用</title>
    <link href="https://xltanglx.github.io/2022/07/23/JUC%E4%B8%8BCountDownLatch%E3%80%81CyclicBarrier%E3%80%81Semaphore%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://xltanglx.github.io/2022/07/23/JUC%E4%B8%8BCountDownLatch%E3%80%81CyclicBarrier%E3%80%81Semaphore%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2022-07-23T07:13:23.000Z</published>
    <updated>2022-08-14T11:39:18.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>wait() 和 notify() 对多个线程进行并发控制太复杂，所以 JUC 提供了一种更轻松的方式实现多线程的并发控制。以下列出了三种方式。</p></blockquote><h1 id="countdownlatch火箭发射倒计时">CountDownLatch(火箭发射倒计时)</h1><h2 id="概念">概念</h2><p>它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望负责启动框架服务的线程全部启动之后再执行。</p><p>CountDownLatch 主要有两个方法，当一个或多个线程调用 await() 方法时，调用线程会被阻塞。其他线程调用 countDown() 方法会将计数器减 1，当计数器的值变为 0 时，因调用 await() 方法被阻塞的线程才会被唤醒，继续执行。</p><h2 id="示例代码">示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//general();</span></span><br><span class="line">        countDownLatchTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">general</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t上完自习，离开教室&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread--&gt;&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123; <span class="comment">//通过阻塞main线程也可以让=====班长最后关门走人最后打印</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t=====班长最后关门走人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countDownLatchTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t被灭&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, CountryEnum.forEach_CountryEnum(i).getRetMessage()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t=====秦统一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CountryEnum</span> </span>&#123;</span><br><span class="line">        ONE(<span class="number">1</span>, <span class="string">&quot;齐国&quot;</span>), TWO(<span class="number">2</span>, <span class="string">&quot;楚国&quot;</span>), THREE(<span class="number">3</span>, <span class="string">&quot;燕国&quot;</span>),</span><br><span class="line">        FOUR(<span class="number">4</span>, <span class="string">&quot;赵国&quot;</span>), FIVE(<span class="number">5</span>, <span class="string">&quot;魏国&quot;</span>), SIX(<span class="number">6</span>, <span class="string">&quot;韩国&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="keyword">private</span> Integer retCode;</span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="keyword">private</span> String retMessage;</span><br><span class="line"></span><br><span class="line">        CountryEnum(Integer retCode, String retMessage) &#123;</span><br><span class="line">            <span class="keyword">this</span>.retCode = retCode;</span><br><span class="line">            <span class="keyword">this</span>.retMessage = retMessage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CountryEnum <span class="title">forEach_CountryEnum</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            CountryEnum[] myArray = CountryEnum.values();</span><br><span class="line">            <span class="keyword">for</span> (CountryEnum countryEnum : myArray) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index == countryEnum.retCode) &#123;</span><br><span class="line">                    <span class="keyword">return</span> countryEnum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">齐国被灭</span><br><span class="line">楚国被灭</span><br><span class="line">赵国被灭</span><br><span class="line">韩国被灭</span><br><span class="line">魏国被灭</span><br><span class="line">燕国被灭</span><br><span class="line">main=====秦统一</span><br></pre></td></tr></table></figure><h1 id="cyclicbarrier集齐七颗龙珠召唤神龙">CyclicBarrier(集齐七颗龙珠召唤神龙)</h1><h2 id="概念">概念</h2><p>CyclicBarrier 的字面意思是可循环 (Cyclic) 使用的屏障 (Barrier)，它要做的事情是让一组线程到达一个屏障（也可叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会被打开，所有被屏障拦截的线程才会继续执行，线程进入屏障通过 CycliBarrier 的 await() 方法。</p><h2 id="示例代码">示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        cyclicBarrierTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cyclicBarrierTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====召唤神龙=====&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t收集到第&quot;</span> + tempInt + <span class="string">&quot;颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>收集到第<span class="number">1</span>颗龙珠</span><br><span class="line"><span class="number">5</span>收集到第<span class="number">5</span>颗龙珠</span><br><span class="line"><span class="number">2</span>收集到第<span class="number">2</span>颗龙珠</span><br><span class="line"><span class="number">6</span>收集到第<span class="number">6</span>颗龙珠</span><br><span class="line"><span class="number">4</span>收集到第<span class="number">4</span>颗龙珠</span><br><span class="line"><span class="number">7</span>收集到第<span class="number">7</span>颗龙珠</span><br><span class="line"><span class="number">3</span>收集到第<span class="number">3</span>颗龙珠</span><br><span class="line">====召唤神龙=====</span><br></pre></td></tr></table></figure><h1 id="semaphore信号量">Semaphore(信号量)</h1><h2 id="概念">概念</h2><p>可以代替 synchronized 和 Lock，<strong>信号量主要有两个应用场景，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制，即可以控制多个线程竞争一个或多个资源。</strong></p><h2 id="示例代码">示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抢车位示例代码，一起有6台汽车，但是只有3个停车位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);<span class="comment">//模拟三个停车位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;<span class="comment">//模拟6台汽车</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t抢到车位&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);<span class="comment">//停车3s</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t停车3s后离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Car &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Car <span class="number">1</span>抢到车位</span><br><span class="line">Car <span class="number">2</span>抢到车位</span><br><span class="line">Car <span class="number">3</span>抢到车位</span><br><span class="line">Car <span class="number">1</span>停车3s后离开车位</span><br><span class="line">Car <span class="number">3</span>停车3s后离开车位</span><br><span class="line">Car <span class="number">6</span>抢到车位</span><br><span class="line">Car <span class="number">2</span>停车3s后离开车位</span><br><span class="line">Car <span class="number">4</span>抢到车位</span><br><span class="line">Car <span class="number">5</span>抢到车位</span><br><span class="line">Car <span class="number">4</span>停车3s后离开车位</span><br><span class="line">Car <span class="number">6</span>停车3s后离开车位</span><br><span class="line">Car <span class="number">5</span>停车3s后离开车位</span><br></pre></td></tr></table></figure><h1 id="小总结">小总结</h1><ul><li>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同。CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</li><li>Semaphore 其实和锁有点类似，它一般用于控制对多个资源的访问权限。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;wait() 和 notify() 对多个线程进行并发控制太复杂，所以 JUC 提供了一种更轻松的方式实现多线程的并发控制。以下列出了三种方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;countdownlatch火箭发射倒计时&quot;&gt;Co</summary>
      
    
    
    
    <category term="Java" scheme="https://xltanglx.github.io/categories/Java/"/>
    
    
    <category term="Java多线程" scheme="https://xltanglx.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java常见的几种锁</title>
    <link href="https://xltanglx.github.io/2022/07/16/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%94%81/"/>
    <id>https://xltanglx.github.io/2022/07/16/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%94%81/</id>
    <published>2022-07-16T14:40:48.000Z</published>
    <updated>2022-08-14T11:38:49.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="锁的类型">锁的类型</h1><h2 id="悲观锁-乐观锁">悲观锁、乐观锁</h2><ul><li>悲观锁和乐观锁并非是一种实际的锁，而是指一种加锁的思想，并非 Java 独有，在其他语言和数据库中都有广泛的应用</li><li>悲观锁在 Java 中一般指代常见的各种锁，比如 synchronized</li><li>乐观锁在 Java 中一般指 CAS 操作</li></ul><h2 id="公平锁-非公平锁">公平锁、非公平锁</h2><ul><li><p><strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁，类似排队打饭；</p></li><li><p><strong>非公平锁</strong>是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象；</p></li><li><p>对 Java ReentrantLock 而言，通过构造函数指定该锁是否公平，默认是非公平锁，非公平锁的优点在于吞吐量比公平锁大；对 synchronized 而言，是一种非公平锁。<strong>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个等待队列。</strong></p></li></ul><h2 id="可重入锁-递归锁">可重入锁 (递归锁)</h2><h3 id="概念">概念</h3><ul><li>同一线程外层方法获得锁之后，内层递归调用外层方法仍能获取该锁；</li><li>同一线程外层方法获得锁之后，内层调用其他同步方法仍能获取该锁；</li></ul><p>也就是说，<strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块。ReentrantLock/synchronized 就是一个典型的可重入锁，可重入锁最大的作用是避免死锁。</strong></p><h3 id="示例代码">示例代码</h3><p><strong>可重入锁代码验证：synchronized</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t -----invoked sendSMS()&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t +++++invoked sendEmail()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">2</span> -----<span class="function">invoked <span class="title">sendSMS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 2 +++++invoked <span class="title">sendEmail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 1 -----invoked <span class="title">sendSMS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 1 +++++invoked <span class="title">sendEmail</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>可重入锁代码验证：ReentrantLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mobile mobile = <span class="keyword">new</span> Mobile();</span><br><span class="line">        <span class="keyword">new</span> Thread(mobile).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mobile).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mobile</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked get()&quot;</span>);</span><br><span class="line">            set();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked set()&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> <span class="function">invoked <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-0 invoked <span class="title">set</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-1 invoked <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread-1 invoked <span class="title">set</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="自旋锁">自旋锁</h2><h3 id="概念">概念</h3><p>是指尝试获取锁的线程获取失败，不会立即被阻塞，而是<strong>采用循环的方式，反复的去尝试获取该锁，直到获取成功</strong>，这样做的好处是减少线程上下文切换的消耗（线程上下文切换将导致操作系统从用户态变为内核态），缺点是循环会消耗 CPU。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自旋锁时间阈值">自旋锁时间阈值</h3><p>在 JDK1.5 自旋锁时间阈值是写死的，在 1.6 引入了<strong>适应性自旋锁</strong>， 适应性意味着自旋的次数不再固定了，而是<strong>由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</strong></p><p>适应性自旋锁基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过 (CPUs/2) 个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU 的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。</p><p><strong>自旋锁的开启</strong><br>JDK1.6 中 -XX:+UseSpinning 开启；<br>-XX:PreBlockSpin=10 为自旋次数，JDK1.7 后，去掉此参数，由 jvm 控制。</p><h3 id="手写自旋锁">手写自旋锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现自旋锁</span></span><br><span class="line"><span class="comment"> * 通过CAS操作完成自旋锁，A线程先进来调用mylock方法自己持有锁5秒钟，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.mylock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.mylock();</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t invoked myunlock()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span> come in</span><br><span class="line">Thread <span class="number">2</span> come in <span class="comment">//Thread2 come in之后不会立即被阻塞，而是卡在while循环，自我旋转</span></span><br><span class="line">Thread <span class="number">1</span> <span class="function">invoked <span class="title">myunlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Thread 2 invoked <span class="title">myunlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="独占锁-写锁共享锁-读锁">独占锁 (写锁)/共享锁 (读锁)</h2><h3 id="概念">概念</h3><ul><li><strong>独占锁</strong>：指该锁一次只能被一个线程所持有，ReentrantLock 和 synchronized 都是独占锁；</li><li><strong>共享锁</strong>：指该锁可被多个线程所持有，可以保证并发读是非常高效的；</li><li><strong>读写锁</strong>：为了提高性能，Java 提供了 ReentrantReadWriteLock  读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，它和 CopyOnWrite 容器不同的是 CopyOnWrite 读写不互斥，不保证数据的实时更新，而 ReentrantReadWriteLock 读写互斥，可以保证数据的实时更新。<strong>ReentrantReadWriteLock 的常见应用场景：缓存 。</strong></li></ul><h3 id="示例代码">示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个线程同时读一个资源类没有任何问题（数据一致），所以为了满足并发量，读取共享资源可以同时进行。</span></span><br><span class="line"><span class="comment"> * 但是如果有一个线程想去写共享资源，那么就不应该再有其他线程对资源进行读或写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 总结：读读能共存、读写不能共存、写写不能共存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + <span class="string">&quot;&quot;</span>, tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写操作：原子+独占</span></span><br><span class="line"><span class="comment">     * 整个过程必须是一个完整的统一体，中间不许被分割，不许被打断</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以正在写入和写入完成需要同时打印出来才行，不可以被分割</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在写入：&quot;</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t写入完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读操作不需要保证原子+独占，所以可以多个线程同时读</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以正在读取和读取完成不需要同时打印</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t正在读取：&quot;</span> + key);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            Object result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t读取完成: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>正在写入：<span class="number">1</span></span><br><span class="line">Thread <span class="number">1</span>写入完成</span><br><span class="line">Thread <span class="number">2</span>正在写入：<span class="number">2</span></span><br><span class="line">Thread <span class="number">2</span>写入完成</span><br><span class="line">Thread <span class="number">4</span>正在写入：<span class="number">4</span></span><br><span class="line">Thread <span class="number">4</span>写入完成</span><br><span class="line">Thread <span class="number">5</span>正在写入：<span class="number">5</span></span><br><span class="line">Thread <span class="number">5</span>写入完成</span><br><span class="line">Thread <span class="number">3</span>正在写入：<span class="number">3</span></span><br><span class="line">Thread <span class="number">3</span>写入完成</span><br><span class="line">Thread <span class="number">1</span>正在读取：<span class="number">1</span></span><br><span class="line">Thread <span class="number">2</span>正在读取：<span class="number">2</span></span><br><span class="line">Thread <span class="number">3</span>正在读取：<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>正在读取：<span class="number">4</span></span><br><span class="line">Thread <span class="number">5</span>正在读取：<span class="number">5</span></span><br><span class="line">Thread <span class="number">2</span>读取完成: <span class="number">2</span></span><br><span class="line">Thread <span class="number">5</span>读取完成: <span class="number">5</span></span><br><span class="line">Thread <span class="number">3</span>读取完成: <span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>读取完成: <span class="number">4</span></span><br><span class="line">Thread <span class="number">1</span>读取完成: <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="偏向锁轻量级锁重量级锁">偏向锁/轻量级锁/重量级锁</h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而<strong>让锁拥有了四个状态</strong>：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p><br><p><strong>重量级锁：</strong> synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁） 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到内核态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p><br><p><strong>轻量级锁：</strong> “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，<strong>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</strong></p><br><p><strong>偏向锁：</strong> Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，<strong>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</strong></p><h2 id="分段锁">分段锁</h2><p>分段锁也并非一种实际的锁，而是一种思想，ConcurrentHashMap 是学习分段锁的最好实践。</p><h1 id="锁的优化">锁的优化</h1><h2 id="减少锁持有的时间">减少锁持有的时间</h2><p>只用在有线程安全要求的程序上加锁。</p><h2 id="减少锁粒度">减少锁粒度</h2><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最典型的减小锁粒度的案例就是 ConcurrentHashMap。</p><h2 id="锁分离">锁分离</h2><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如 LinkedBlockingQueue 从头部取出，从尾部放数据。</p><h2 id="锁粗化">锁粗化</h2><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p><h2 id="锁消除">锁消除</h2><p>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。<br>参考：<a href="https://www.jianshu.com/p/39628e1180a9">Java 锁 - 导读 </a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;锁的类型&quot;&gt;锁的类型&lt;/h1&gt;
&lt;h2 id=&quot;悲观锁-乐观锁&quot;&gt;悲观锁、乐观锁&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;悲观锁和乐观锁并非是一种实际的锁，而是指一种加锁的思想，并非 Java 独有，在其他语言和数据库中都有广泛的应用&lt;/li&gt;
&lt;li&gt;悲观锁在 Java 中</summary>
      
    
    
    
    <category term="Java" scheme="https://xltanglx.github.io/categories/Java/"/>
    
    
    <category term="Java多线程" scheme="https://xltanglx.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java常见的线程不安全的集合类</title>
    <link href="https://xltanglx.github.io/2022/07/15/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>https://xltanglx.github.io/2022/07/15/Java%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB/</id>
    <published>2022-07-15T15:11:06.000Z</published>
    <updated>2022-08-14T11:38:24.804Z</updated>
    
    <content type="html"><![CDATA[<p>线程不安全的集合：当多个线程同时对非线程安全的集合进行增删改的时候会破坏集合的数据完整性。例如：当多个线程访问同一个集合时，如果有超过一个线程同时在修改集合，则程序必须手动保证该集合的同步性。</p><h1 id="arraylist">ArrayList</h1><h2 id="不安全的-arraylist-实例">不安全的 ArrayList 实例</h2><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合类不安全问题</span></span><br><span class="line"><span class="comment"> * ArrayList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerNotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        notSafe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 故障现象</span></span><br><span class="line"><span class="comment">     * java.util.ConcurrentModificationException：并发修改异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread 10&quot;</span> java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure><h2 id="异常原因"><s>异常原因</s></h2><p>并发修改异常：ArrayList 类的 <code>add()</code> 方法是没有添加 <code>synchronized</code> 关键字修饰的，所以多个线程可以同时进入 <code>add()</code> 方法，当一个线程正在写入，另一个线程前来抢夺，就会导致后一个线程的写入覆盖了前一个线程的写入。</p><h2 id="三种解决方法">三种解决方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();<span class="comment">//Vector线程安全</span></span><br><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());<span class="comment">//使用辅助工具类</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();<span class="comment">//写时复制，读写分离</span></span><br></pre></td></tr></table></figure><ul><li><code>Vector</code> 和 <code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code> 的底层原理是一样的，都是对 add 操作添加 <code>synchronized</code> 关键字修饰，在一个线程执行 add 操作的时候，不允许其他线程进入 add 。</li><li><code>new CopyOnWriteArrayList&lt;&gt;()</code> 是通过 ReentrantLock 保证线程安全的。</li></ul><p><strong>CopyOnWriteArrayList.add 方法（加分）</strong></p><p>CopyOnWrite 容器即写时复制，读写分离，往一个容器添加元素的时候，不直接在当前容器 Object[] 添加，而是先将当前容器 Object[] 进行 copy，复制出一个新的容器 Object[] newElements，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新的容器 setArray(newElements)，这样做可以对 CopyOnWrite 容器进行并发的读，而且不需要加锁，因为原容器不会添加任何元素（数据一致），所以 CopyOnWrite 容器也是一种读写分离的思想，读和写分别在不同的容器。</p><p>下面是 CopyOnWriteArrayList.add 的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray(); <span class="comment">//原容器</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">//新容器，容量要加1</span></span><br><span class="line">        newElements[len] = e; <span class="comment">//往新容器中写</span></span><br><span class="line">        setArray(newElements); <span class="comment">//将原容器的引用指向新容器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不足</strong>：CopyOnWrite 容器读和写分别在不同的容器，读写是不互斥的，所以无法保证数据的实时更新。</p><h1 id="hashmap">HashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure><h1 id="hashset">HashSet</h1><p>HashSet 的底层是一个 HashMap，存储的值放在 HashMap 的 key 里，value 存储了一个名称为 PRESENT 的静态常量 Object 对象，也就是说 value 形同虚设。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; list = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">Set&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;(); <span class="comment">//它的底层是一个CopyOnWriteArrayList，但是它用的不是List&lt;String&gt; list的add()方法，而是addIfAbsent(e)，保证元素是唯一的</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线程不安全的集合：当多个线程同时对非线程安全的集合进行增删改的时候会破坏集合的数据完整性。例如：当多个线程访问同一个集合时，如果有超过一个线程同时在修改集合，则程序必须手动保证该集合的同步性。&lt;/p&gt;
&lt;h1 id=&quot;arraylist&quot;&gt;ArrayList&lt;/h1&gt;
&lt;h</summary>
      
    
    
    
    <category term="Java" scheme="https://xltanglx.github.io/categories/Java/"/>
    
    
    <category term="Java多线程" scheme="https://xltanglx.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS和ABA问题</title>
    <link href="https://xltanglx.github.io/2022/07/10/CAS%E5%92%8CABA%E9%97%AE%E9%A2%98/"/>
    <id>https://xltanglx.github.io/2022/07/10/CAS%E5%92%8CABA%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-10T15:38:41.000Z</published>
    <updated>2022-08-14T11:38:00.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cas">CAS</h1><h2 id="compareandset-比较并交换">compareAndSet 比较并交换</h2><p><code>AtomicInteger.compareAndSet(int expect, indt update)</code>，第一个参数为当前线程认为的期望值，如果此时主内存共享变量的值和期望值一致，则进行 update 赋值，如果和期望值不一致，说明共享变量被其他线程修改过，返回 fasle，取消赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS是什么？</span></span><br><span class="line"><span class="comment"> * 比较并交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       checkCAS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkCAS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>) + <span class="string">&quot;\t current data is &quot;</span> + atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2014</span>) + <span class="string">&quot;\t current data is &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span> current data is <span class="number">2019</span></span><br><span class="line"><span class="keyword">false</span> current data is <span class="number">2019</span></span><br></pre></td></tr></table></figure><h2 id="cas-底层原理">CAS 底层原理</h2><h3 id="unsafe-类">Unsafe 类</h3><p><code>atomicInteger.getAndIncrement();</code>的底层实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>); <span class="comment">//unsafe对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Unsafe 是 CAS 的核心类，存在于 <code>sun.misc</code> 包下，由于 Java 方法无法直接访问底层系统，需要通过本地（native）方法来访问。<strong>Unsafe 类中的方法大多数都是 native 修饰的，也就是说 Unsafe 类中的方法大多数都可以直接调用操作系统底层资源执行相应任务</strong>；</li><li>变量 this ，表示该变量在内存中的起始地址；</li><li>变量 valueOffset，表示该变量在内存中的偏移地址，因为 Unsafe 就是根据内存地址获取数据的；</li><li>1 表示当前变量的值加 1 （相当于 i++）。</li></ul><h3 id="底层原理">底层原理</h3><p>CAS 全称 Compare-And-Swap，<strong>它是一条 CPU 并发原语</strong>，它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值；如果不是则重新获取该位置内存的值继续比较，直到更新成功。这个过程是原子的（不可分割的）。</p><p>CAS 并发原语体现在 JAVA 语言中就是 <code>sun.misc.Unsafe</code> 类中各个方法。调用 Unsafe 类中的 CAS 方法，JVM 会帮我们实现 CAS 汇编指令，这是一种完全依赖于硬件的功能，通过它可以实现原子操作。由于 CAS 是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，<strong>也就是说 CAS 是一条 CPU 的原子指令，不会造成数据不一致问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unsafe.getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>var1：AtomicInteger 对象本身（变量在内存的起始地址）；</li><li>var2：该对象的引用地址（变量在内存的偏移地址）；</li><li>var4：需要变动的数据（加 1 操作）；</li><li>var5：期望值；</li><li>如果当前主内存的值和 var5 相同，则更新主内存的值为 var5+var4，并且返回 var5；</li><li>如果不同，继续去获取，然后再比较，直到更新完成（通过循环，反复尝试）；</li><li><strong>CAS的关键实现</strong>有CPU并发原语（比较&amp;交换的过程是原子的）、自旋（无需上下文切换&amp;能够拿到主内存的最新值）、volatile修饰变量（及时通知其他线程）。</li></ul><h3 id="cas-缺点">CAS 缺点</h3><ol><li><p><strong>循环时间长，开销大（自旋）</strong></p><p>例如 getAndAddInt 方法执行，有个 do while 循环，如果 CAS 失败，一直会进行尝试，如果 CAS 长时间不成功，可能会给 CPU 带来很大的开销。</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong></p><p>对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p></li><li><p><strong>ABA 问题</strong></p></li></ol><h1 id="aba-问题">ABA 问题</h1><h2 id="aba-问题如何产生">ABA 问题如何产生</h2><p>比如<strong>线程 1</strong>从内存位置 V 取出 A，<strong>线程 2</strong>同时也从内存取出 A，并且线程 2 进行一些操作将值改为 B，然后线程 2 又将 V 位置数据改回 A，这时候线程 1 进行 CAS 操作发现内存中的值依然是 A，然后线程 1 操作成功。</p><p><strong>尽管线程 1 的 CAS 操作成功，但是不代表这个过程没有问题。</strong></p><h2 id="如何解决-aba-问题">如何解决 ABA 问题</h2><p><strong>版本号机制：为共享变量设置版本号，在进行 CAS 操作的时候，比较两者的版本号是否相等，只有相等时 CAS 操作才能执行成功，每成功执行一次 CAS 操作，共享变量的版本号要加一，版本号只会增加不会减少。</strong></p><p>示例代码（带时间戳的原子引用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ABA问题解决</span></span><br><span class="line"><span class="comment"> * AtomicStampedReference</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====以下时ABA问题的产生=====&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//保证线程1完成一次ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;=====以下时ABA问题的解决=====&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第1次版本号&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第2次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第3次版本号&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第1次版本号&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t修改是否成功&quot;</span> + result + <span class="string">&quot;\t当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t当前最新实际值：&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;Thread 4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">=====以下时ABA问题的产生=====</span><br><span class="line"><span class="keyword">true</span><span class="number">2019</span></span><br><span class="line">=====以下时ABA问题的解决=====</span><br><span class="line">Thread <span class="number">3</span>第<span class="number">1</span>次版本号<span class="number">1</span></span><br><span class="line">Thread <span class="number">4</span>第<span class="number">1</span>次版本号<span class="number">1</span></span><br><span class="line">Thread <span class="number">3</span>第<span class="number">2</span>次版本号<span class="number">2</span></span><br><span class="line">Thread <span class="number">3</span>第<span class="number">3</span>次版本号<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>修改是否成功<span class="keyword">false</span>当前最新实际版本号：<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>当前最新实际值：<span class="number">100</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cas&quot;&gt;CAS&lt;/h1&gt;
&lt;h2 id=&quot;compareandset-比较并交换&quot;&gt;compareAndSet 比较并交换&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;AtomicInteger.compareAndSet(int expect, indt update)&lt;/c</summary>
      
    
    
    
    <category term="Java" scheme="https://xltanglx.github.io/categories/Java/"/>
    
    
    <category term="Java多线程" scheme="https://xltanglx.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>对volatile的一些理解</title>
    <link href="https://xltanglx.github.io/2022/07/07/%E5%AF%B9volatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>https://xltanglx.github.io/2022/07/07/%E5%AF%B9volatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</id>
    <published>2022-07-07T11:58:32.000Z</published>
    <updated>2022-08-14T11:31:04.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-内存模型">Java 内存模型</h1><p>JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，它描述的是一组规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><p>JMM 三大特性：可见性、原子性、有序性。</p><p><strong>JMM 规范：<strong>线程在 JVM 中运行，JVM 会为每个线程创建一个</strong>工作内存</strong>，工作内存是每个线程的私有数据区域，而 Java 内存模型规定所有变量都存储在<strong>主内存</strong>，主内存是共享内存区域，所有线程都可以访问，<strong>但是线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存，<strong>不能直接操作主内存中的变量，各个线程的工作内存中存储着主内存的</strong>变量副本拷贝</strong>，线程间的通信（传值）必须通过主内存来完成，期间访问过程如下图：</p><img src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/对volatile的一些理解.assets/g4ICK9.png" alt="g4ICK9.png" border="0" style="zoom:67%;"><h1 id="对-volatile-的理解">对 volatile 的理解</h1><p>volatile 是 Java 虚拟机提供的轻量级的同步机制，保证可见性、不保证原子性、禁止指令重排。</p><h2 id="保证可见性">保证可见性</h2><p>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即得到这个最新的值。</p><p>验证示例（对 num 共享变量不添加 volatile 和添加 volatile）</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证volatile的可见性</span></span><br><span class="line"><span class="comment"> * 如果int num = 0，number变量没有添加volatile关键字修饰</span></span><br><span class="line"><span class="comment"> * 添加了volatile，保证可见性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        visibilityByVolatile();<span class="comment">//验证volatile的可见性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile可以保证可见性，及时通知其他线程主内存的值已经被修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visibilityByVolatile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程暂停3s</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                myData.addToSixty();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t update value:&quot;</span> + myData.num);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;thread1&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二个线程是main线程</span></span><br><span class="line">        <span class="comment">//main线程首次访问num时，会从主内存中取值，所以要想演示可见性这个case，线程AAA的num增加操作要在main线程访问num之后</span></span><br><span class="line">        <span class="comment">//如果num未用volatile修饰，线程AAA修改num后，main线程不感知，num仍然等于0（CPU cache中获取num的值）</span></span><br><span class="line">        <span class="comment">//如果num用volatile修饰，线程AAA修改num后，强制main线程从主内存获取num，num等于60（跳过CPU cache）</span></span><br><span class="line">        <span class="keyword">while</span> (myData.num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果myData的num一直为零，main线程一直在这里循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t mission is over, num value is &quot;</span> + myData.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//volatile int num = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToSixty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread1 come in</span><br><span class="line">thread1 update value:<span class="number">60</span></span><br><span class="line"><span class="comment">//线程进入死循环</span></span><br></pre></td></tr></table></figure><p>当我们改为<code>volatile int num = 0;</code>后的输出结果为：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread1 come in</span><br><span class="line">thread1 update value:<span class="number">60</span></span><br><span class="line">main mission is over, num value is <span class="number">60</span></span><br><span class="line"><span class="comment">//程序没有死循环，结束执行</span></span><br></pre></td></tr></table></figure><img src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/对volatile的一些理解.assets/rCFldZ.jpg" alt="rCFldZ.jpg" border="0"><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从主内存中读，跳过 CPU cache 这一步。</p><h2 id="不保证原子性">不保证原子性</h2><p>原子性：当某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，这个线程下的所有操作<strong>要么同时成功，要么同时失败</strong>。</p><p>验证示例（变量添加 volatile 关键字，方法不添加 synchronized）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证volatile不保证原子性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        atomicByVolatile();<span class="comment">//验证volatile不保证原子性</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile不保证原子性</span></span><br><span class="line"><span class="comment">     * 以及使用Atomic保证原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicByVolatile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                    myData.addSelf();</span><br><span class="line">                    myData.atomicAddSelf();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;Thread &quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//等待上面的线程都计算完成后，再用main线程取得最终结果值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后台至少有两个线程，一个是main线程，一个是gc线程</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally num value is &quot;</span>+myData.num);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally atomicnum value is &quot;</span>+myData.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToSixty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i++操作被编译器编译为多条原子指令，比如：getfied、iconst、iadd、putfield，这些操作volatile无法保证原子性。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSelf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">atomicAddSelf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行三次结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">main <span class="keyword">finally</span> num value is <span class="number">19580</span></span><br><span class="line">main <span class="keyword">finally</span> atomicnum value is <span class="number">20000</span></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">main <span class="keyword">finally</span> num value is <span class="number">19999</span></span><br><span class="line">main <span class="keyword">finally</span> atomicnum value is <span class="number">20000</span></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">main <span class="keyword">finally</span> num value is <span class="number">18375</span></span><br><span class="line">main <span class="keyword">finally</span> atomicnum value is <span class="number">20000</span></span><br><span class="line"><span class="comment">//num并没有达到20000</span></span><br></pre></td></tr></table></figure><h2 id="禁止指令重排">禁止指令重排</h2><p>有序性：在计算机执行程序时，为了提高性能，编译器和处理器常常会对<strong>指令进行重排</strong>。一般分以下三种：</p><img src="https://gcore.jsdelivr.net/gh/xltanglx/CDN/blog/对volatile的一些理解.assets/caytz5.png" alt="caytz5.png" border="0"><p>处理器在进行指令重排时必须要考虑指令之间的<strong>数据依赖性</strong>，只有没有数据依赖的指令才可能被重排。</p><p>单线程环境下程序最终执行的结果和代码顺序执行的结果一致，但是多线程环境下线程交替执行，由于编译器指令重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果也无法预测。</p><p>重排代码实例，声明变量：<code>int a,b,x,y=0</code></p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>结果</td><td>x = 0      y=0</td></tr></tbody></table><p>如果编译器对这段程序代码执行重排优化后，可能出现如下情况：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x= a;</td><td>y = b;</td></tr><tr><td>结果</td><td>x = 2      y=1</td></tr></tbody></table><p>使用 volatile 可以禁止指令重排，从而避免了多线程环境下程序出现乱序执行的现象。</p><p><strong>内存屏障</strong>（Memory Barrier）又称内存栅栏，是一个 CPU 指令，它的作用有两个：</p><ol><li>保证特定操作的执行顺序；</li><li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）。</li></ol><p><strong>重排序时不能把后面的指令放到内存屏障之前</strong>。内存屏障的另外一个作用是强制刷出各种 CPU 的缓存数据，因此任何 CPU 上的线程都能读取到这些数据的最新版本（就是可见性）。</p><h1 id="volatile-的适用场景">volatile 的适用场景</h1><p>总结：<strong>volatile 适合这种场景，一个变量被多个线程共享，线程直接给这个变量赋值。</strong></p><p>值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++ 这种操作的原子性，因为本质上 i++ 是读、写两次操作。在某些场景下可以代替 synchronized。但是，volatile 不能完全取代 synchronized 的位置，只有在一些特殊的场景下，才能使用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：</p><ul><li>对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）；</li><li>该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul><h1 id="你在哪些地方用过-volatile">你在哪些地方用过 volatile</h1><h2 id="线程不安全的单例模式">线程不安全的单例模式</h2><p>普通的单例模式在多线程情况下，其构造方法可能会被执行多次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 构造方法SingletonDemo（）&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造方法只会被执行一次</span></span><br><span class="line">        <span class="comment">//System.out.println(getInstance() == getInstance());</span></span><br><span class="line">        <span class="comment">//System.out.println(getInstance() == getInstance());</span></span><br><span class="line">        <span class="comment">//System.out.println(getInstance() == getInstance());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//并发多线程后，构造方法会在一些情况下执行多次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全的单例模式">线程安全的单例模式</h2><p>所以使用 DCL （Double Check Lock双端检锁机制）在加锁前和加锁后都进行一次判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SingletonDemo.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为指令重排的存在，DCL（双端检锁）机制仍然不一定线程安全。</strong></p><p><code>instance=new SingleDemo();</code>可以被分为以下三步（伪代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;<span class="comment">//3.设置instance执行刚分配的内存地址，此时instance!=null</span></span><br></pre></td></tr></table></figure><p>步骤 2 和步骤 3 不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的，<strong>如果 3 步骤提前于步骤 2，但是 instance 还没有初始化完成，所以当一个线程访问 instance 不为 null 时，由于 instance 实例未必已初始化完成，也就造成了线程安全问题。</strong></p><p>为了解决以上问题，可以将 SingletongDemo 实例上加上 volatile。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-内存模型&quot;&gt;Java 内存模型&lt;/h1&gt;
&lt;p&gt;JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，它描述的是一组规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://xltanglx.github.io/categories/Java/"/>
    
    
    <category term="Java多线程" scheme="https://xltanglx.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
